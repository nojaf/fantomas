[{"uri":"/fantomas/docs/index.html","title":"Fantomas\n","content":"Fantomas\n========\n\n[![Build Status Github Actions](https://github.com/fsprojects/fantomas/workflows/Build%20main/badge.svg?branch=main\u0026event=push)](https://github.com/fsprojects/fantomas/actions)\n[![Discord](https://img.shields.io/discord/940511234179096586?label=Fantomas%20Discord\u0026style=flat-square)](https://discord.gg/D5QXvQrBVa)\n\nF# source code formatter, inspired by [scalariform](https://github.com/mdr/scalariform) for Scala, [ocp-indent](https://github.com/OCamlPro/ocp-indent) for OCaml and [PythonTidy](https://pypi.org/project/PythonTidy/) for Python.\n\n## Purpose\nThis project aims at formatting F# source files based on a given configuration.\nFantomas will ensure correct indentation and consistent spacing between elements in the source files.\nWe assume that the source files are *parsable by F# compiler* before feeding into the tool.\nFantomas follows two F# style guides: the [F# code formatting guidelines](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting) from Microsoft by default and the [G-Research F# code formatting guidelines](https://github.com/G-Research/fsharp-formatting-conventions) via various [settings](https://github.com/G-Research/fsharp-formatting-conventions/blob/main/.editorconfig).\n\n## Contributing Guidelines\n\nSee the [Contribution Guidelines](https://github.com/fsprojects/fantomas/blob/main/CONTRIBUTING.md).\n\n## Credits\nWe would like to gratefully thank the following persons for their [contributions](https://github.com/fsprojects/fantomas/graphs/contributors).\n\n## License\nThe library and tool are available under Apache 2.0 license.\nFor more information see the [License file](https://github.com/fsprojects/fantomas/blob/main/LICENSE.md).\n\n\u003Cfantomas-nav next=\u0022./end-users/GettingStarted.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/contributors/Glossary.html","title":"Glossary\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 1000\n---\n# Glossary\n\n## AST\n\nThe [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST) is a tree data [structure](https://github.com/dotnet/fsharp/blob/main/src/Compiler/SyntaxTree/SyntaxTree.fsi) representing a piece of source code.\n\n## FCS\n\n[FSharp.Compiler.Service](https://fsharp.github.io/fsharp-compiler-docs/fcs/#FSharp-Compiler-Service) (FCS) is a collection of APIs and Services derived from the F# compiler source code.\n\n## PR\n\nA [Pull Request](https://docs.github.com/en/pull-requests) (PR) is a unit of proposed changes to a version control repository. See [here](./Pull%20request%20ground%20rules.html) for Fantomas-specific rules.\n\n## Range\n\nA data structure modeling the exact place and size of a node or language construct in the source code.  \nA _range_ has a start and end position. A position is composed of a line number and a column number.\n\n## Style Guide\n\nThe [F# Style Guide](https://learn.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting). The set of formatting rules Fantomas implements.\n\n## Syntax Node\n\nA node in the AST. A node can represent different types of syntax, e.g. a Record or a Lambda.\n\n## Trivia\n\n_Trivia_ has two meanings, depending on the context it is used in.\n\n### Fantomas\n\nUsed to label items (blank lines, code comments, conditional directives) that are not fully captured by the F# compiler in the AST.\n\n### FSharp.Compiler.Service\n\nAdditional information captured in the [syntax tree](https://github.com/dotnet/fsharp/blob/main/src/Compiler/SyntaxTree/SyntaxTrivia.fsi), which the compiler does not need to compile the source code.\n\n## Trivia Node\n\nA _trivia node_ can contain _trivia_, either as content before or content after.\nA _trivia node_ is a generalized type that serves as a common denominator for all AST node types.  \n_Trivia nodes_ are used to construct a hierarchical tree-like structure in which every node can have multiple child nodes and each node has one parent node.\n\n## Typed Syntax Tree\n\nThe AST from the FCS carrying typed information about the processed source code. It is contructed from the _Untyped Syntax Tree_.  \nFantomas does not use this AST to format the source code.\n\n## Untyped Syntax Tree\n\nThe AST from the FCS used by Fantomas.\nIt represents the source code as it was processed by the F# compiler. The _Untyped Syntax Tree_ doesn\u0027t carry any information regarding the validity of the source code or semantics.\nIn a later compilation stage, the _Untyped Syntax Tree_ is transformed into the _Typed Syntax Tree_.\n\n\u003Cfantomas-nav previous=\u0022./Pull%20request%20ground%20rules.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/contributors/How Can I Contribute.html","title":"How can I contribute?\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 9\n---\n# How can I contribute?\n\nThere are many ways to contribute to an open-source project. From liking a tweet to show some interest to solving a heavy handed coding problem.   \nThe most obvious thing where we can use some help is fixing bugs, but there are a lot of other things that most certainly would be welcome.\n\n## Bug fixes\n\n**The most welcome additions to the project are bug fixes**. The philosophy behind this is that everyone should be able to fix their own bug.\nIf we can achieve this as a community, we can share the workload and all benefit together.\nThe project can move at a faster pace and improve as a whole.\n\nWe strongly encourage people to embrace the reward of solving their own problems.\nWe\u0027ll ask for a regression test when you fix a bug, to guarantee that you won\u0027t encounter the bug again.\n\n### bug (soundness)\n\nOur goal is for Fantomas to be able to format all files out of the box without breaking correctness.\nIt\u0027s very important to us that a new user\u0027s experience is smooth and at the very least results in correct code.\nBugs labelled \u0060bug (soundness)\u0060 all indicate places where a new user might bounce off Fantomas because it actually broke their code.\nWe want to make sure users get a chance to explore the settings and tweak the style.\nIf you can help us out by fixing a soundness bug, you can really help the project move forward.\n\n### bug (stylistic)\n\nBesides breaking correctness another kind of bug is that the style of the output might not be what you expect.\nBugs like this are labelled as \u0060bug (stylistic)\u0060.\nThis includes cases where Fantomas breaks one of its own formatting rules or fails to respect one of its settings.\n\nAgain, here: scratch your own itch. If something bothers you, the best cure is to try a take a stab at it yourself.\n\n## Good first issues\n\nIf you wish to solve an issue, but don\u0027t know where to start, you can take a look that [good first issue](https://github.com/fsprojects/fantomas/issues?q=is%3Aissue\u002Bis%3Aopen\u002Blabel%3A%22good\u002Bfirst\u002Bissue%22) list.  \nThese issues are typically easier to pick up and might only require a few small changes to solve them.\n\nIn case you want to solve any issue and would like some more guidance to start, you can also just ask this on the GitHub issue.\nThe maintainer can give you additional pointers to get you on your way.\n\n## Adoption\n\nThe dream is that every F# developer can use Fantomas at any time.\nThis aspiration is an odyssey that might never be complete, but any step in that direction is most welcome.\nTry introducing automatic formatting in your project, at work, or in an open-source project.\nThis tool will only improve by adoption.\n\n### fsprojects\n\nAs Fantomas is part of the [F# Community Project Incubation Space](https://github.com/fsprojects/), it would be nice to see all the sibling projects formatted as well.  \nWe\u0027ve put a lot of emphasis on [continued formatting](../end-users/FormattingCheck.md) using the \u0060--check\u0060 flag. Having that **CI setup** in place **really brings it home**.\n\n### Big fish\n\nFor marketing purposes, it is also very interesting if a larger or well-known project is using Fantomas.  \nWe can put these on our [landing page](../../index.html#who-uses-fantomas) and that really sends a strong message.\n\n### Any fish really\n\nRegardless of size or type of project. Any project that checks Fantomas in their CI system [is most welcome](https://youtu.be/IQXby29_tVo).\n\n## Sponsoring\n\nFantomas grew significantly as a result of its first sponsorship deal with [G-Research](https://www.gresearch.co.uk/).  \nIt would still be in the dark ages if it weren\u0027t for this support. For that we will forever be grateful.  \nIf you want to help increase adoption by providing financial support, you can reach out to [sponsoring@fantomas.io](mailto:sponsoring@fantomas.io).\n\n## Keeping the grass green\n\nThere are also some smaller deeds that can benefit the codebase.\n\n### Eliminate dead code\n\nHere and there, there are parts of code that are no longer being used. Ranging from unused parameters to complete functions.  \nA PR that cleans up these things would be appreciated as well.\n\n### Linting\n\nUsing F# Lint or other editor tooling, sometimes small improvements can be detected. Redundant parenthesis for example.  \nTweaks like this are nice.\n\n## Understand how things work\n\nOne other thing that changes your perception of code all together is knowing how Fantomas does what it does.  \nHaving a sense of the inner workings of Fantomas can be beneficial in understanding how the output was achieved.  \n\nIt broadens your horizon in general, as it touched a lot of interesting concepts, and you start looking differently at your F# code.  \nYour sentiment on what you think matters might change, once you realized the level of complexity it involves.\n\n## Documentation\n\nFound a typo? Still confused about something? Do you have some knowledge that should totally be documented?  \nLet us know! We really value any contribution to our documentation. The more knowledge is here, the brighter the future of the project.  \nPlease do no hesitate here \uD83D\uDE0A.\n\nYou can find some instructions on running the documentation locally in the [.README.md](https://github.com/fsprojects/fantomas/blob/main/docs/.README.md) file in the \u0060docs\u0060 folder.  \nThe only prerequisite to run the docs, is having a recent local dotnet sdk.\n\n## New releases\n\nTesting out new releases is also a huge way to help us. Spotting regressions early really helps to fix them early.\n\n### Move to the latest\n\nAlways try and stay on the latest version of Fantomas for your day-to-day projects.  \nUpdating to the newer version that might only have a couple of fixes might seem insignificant, but it really helps.\n\n### Try alphas and betas\n\nPlease give an alpha a spin if you are interested in submitting feedback for new development.  \nTry both versions if you want to make sure everything still works for you.\n\nDon\u0027t feel obliged to use an alpha/beta in your day-to-day flow, just try them to see if the potential next stable version will still work.  \nWe have **over 2000 unit tests**, that still doesn\u0027t tell us if the next release will break your code or not.\n\n## Improve the Syntax Tree\n\nFantomas uses the parser from the F# compiler to construct the untyped syntax tree.  \nThis tree is later used to reconstruct the code. The better the tree, the better Fantomas can operate on it.  \nThe tree can be improved over at [dotnet/fsharp](https://github.com/dotnet/fsharp) when a valid use-case appears.\n\n### Trivia nodes\n\nTrivia nodes in the syntax tree are nodes the compiler doesn\u0027t need to compile the code. However, for Fantomas they can be the missing link to perfectly restore the code.\n\nFor example, in issue [#2360](https://github.com/fsprojects/fantomas/issues/2360), the information about the \u0060and\u0060 keyword is missing in the syntax tree.  \nIf this information was available in [SynTypeDefnTrivia](../../reference/fsharp-compiler-syntaxtrivia-syntypedefntrivia.html), the bug could be fixed.\n\n### Better representation\n\nSometimes the existing shape of the syntax tree doesn\u0027t quite cover the syntax perfectly.\n\nFor example, in issue [#2264](https://github.com/fsprojects/fantomas/issues/2264), the measure was represented as\n\nCode:\n\u0060\u0060\u0060fsharp\n[\u003CMeasure\u003E] type herth = / second\n\u0060\u0060\u0060\n\nOld AST:\n\u0060\u0060\u0060fsharp\nTypes\n   ([SynTypeDefn\n       (SynComponentInfo\n          ([{ Attributes = [ ... ], None, [], [herth],\n           PreXmlDoc ((1,0), FSharp.Compiler.Xml.XmlDocCollector),\n           false, None, tmp.fsx (1,17--1,22)),\n        Simple\n          (TypeAbbrev\n             (Ok,\n              Tuple\n                (false,\n                 [(true,\n                   StaticConstant (Int32 1, tmp.fsx (1,25--1,33)));\n                  (false,\n                   LongIdent (SynLongIdent ([second], [], [None])))], ...]\n\u0060\u0060\u0060\n\nNotice \u0060StaticConstant (Int32 1, ...)\u0060, the source code doesn\u0027t contain any \u00601\u0060 at all.\n\nAfter [dotnet/fsharp#13440](https://github.com/dotnet/fsharp/pull/13440),\n\nNew AST:\n\u0060\u0060\u0060fsharp\nTypes\n             ([SynTypeDefn\n                 (SynComponentInfo\n                    ([{ Attributes =\n                         [{ TypeName = SynLongIdent ([Measure], [], [None])\n                            ArgExpr = Const (Unit, tmp.fsx (1,2--1,9))\n                            Target = None\n                            AppliesToGetterAndSetter = false\n                            Range = tmp.fsx (1,2--1,9) }]\n                        Range = tmp.fsx (1,0--1,11) }], None, [], [herth],\n                     PreXmlDoc ((1,0), FSharp.Compiler.Xml.XmlDocCollector),\n                     false, None, tmp.fsx (1,17--1,22)),\n                  Simple\n                    (TypeAbbrev\n                       (Ok,\n                        Tuple\n                          (false,\n                           [Slash tmp.fsx (1,25--1,26);\n                            Type\n                              (LongIdent (SynLongIdent ([second], [], [None])))],\n                           tmp.fsx (1,25--1,33)), tmp.fsx (1,25--1,33)), ... ]\n\u0060\u0060\u0060\n\nThis update to the tree made it very straightforward to fix the original bug in Fantomas.\n\nAnother example of code that could benefit from a better representation is [extern](https://github.com/fsprojects/fantomas/issues?q=is%3Aissue\u002Bis%3Aopen\u002Bextern).\n\n\u003Cfantomas-nav previous=\u0022./Conditional%20Compilation%20Directives.html\u0022 next=\u0022./The%20Missing%20Comment.html\u0022\u003E\u003C/fantomas-nav\u003E"},{"uri":"/fantomas/docs/contributors/Print AST with Context.html","title":"Fantomas.Core overview (2)\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 6\n---\n# Fantomas.Core overview (2)\n\nOnce the \u0060Context\u0060 is constructed, we can traverse the syntax tree to capture all the \u0060WriterEvent\u0060s.\n\n\u003Cdiv class=\u0022mermaid text-center\u0022\u003E\ngraph TD\n    A[Prepare Context] --\u003E B\n    B[Print AST with Context] --\u003E C[Formatted code]\n    style B stroke:#338CBB,stroke-width:2px\n \u003C/div\u003E\n\nWe enter the module of \u0060CodePrinter\u0060 and try and reconstruct the code based on the given configuration.\n\n## WriterEvents and WriterModel\n\nIn previous versions of Fantomas, \u0060Context\u0060 had a [TextWriter](https://docs.microsoft.com/en-us/dotnet/api/system.io.textwriter?view=net-6.0) that was used to write the output.\nThis is a more advanced version of a \u0060StringBuilder\u0060 and we wrote the formatted code directly to the buffer.\n\nThe key problem with this approach was that we couldn\u0027t easily revert code that was written to the buffer.  \nFor example, if the formatted code was crossing the \u0060max_line_length\u0060, we couldn\u0027t easily revert the code and try an alternative.\n\nThat is why we first capture a collection of \u0060WriterEvent\u0060s and then reconstruct the formatted code.  \nIf the code is too long, we can drop the last events and try an alternative.\n\n### WriterModel\n\nWhen we capture new events we also want to capture the current state of the result.  \nThis happens in the \u0060WriterModel\u0060 record. There we store the result of each event as if it were finalized.  \nBy doing this, we can assert the result of the output. For example if our code is too long or not.\n\n\u0060WriterEvents\u0060 and \u0060WriterModel\u0060 are very stable in the code base.  \nWhen solving a bug, you typically need to change the collected series of events by using a different helper function inside \u0060CodePrinter\u0060.\n\n### CodePrinter\n\nIn \u0060CodePrinter\u0060 the syntax tree is being traversed with the help of various (partial) active patterns.  \nThese active patterns are defined in \u0060SourceParser\u0060 and typically are used to present the information we are interested in, in a different shape.\n\n\u0060CodePrinter\u0060 exposes one function \u0060genParsedInput\u0060.\n\n\u0060\u0060\u0060fsharp\nval genParsedInput:\n    astContext: ASTContext -\u003E ast: FSharp.Compiler.Syntax.ParsedInput -\u003E (Context.Context -\u003E Context.Context)\n\u0060\u0060\u0060\n\nThis takes an \u0060ASTContext\u0060 and the syntax tree.  \nIt returns a function that takes a \u0060Context\u0060 and returns a new \u0060Context\u0060.\n\nWe will eventually call this function with our previously constructed \u0060Context\u0060.  \nIn this function, all events are captured and stored in the \u0060WriterEvents\u0060 and \u0060WriterModel\u0060.\n\nWhile we are traversing the syntax tree, we will compose the \u0060Context -\u003E Context\u0060 function based on the content.\n\u0060Context.dump\u0060 then eventually takes the \u0060Context\u0060 and returns a \u0060string\u0060 of formatted code.\n\nThis may seem a bit complicated, but you typically can see this as an implementation detail and can abstract this when working in \u0060CodePrinter\u0060.\n\n### Creating WriterEvents\n\nThere are various helper functions in \u0060CodePrinter\u0060 that create \u0060WriterEvent\u0060s.  \nIn \u0060CodePrinter\u0060 we will typically never construct a \u0060WriterEvent\u0060 directly.\n\nInstead we can use various helper functions that take the \u0060Context\u0060 as parameter and return an updated \u0060Context\u0060 with additional events.  \nPlease take a moment to debug the unit tests in [CodePrinterHelperFunctionsTests.fs](https://github.com/fsprojects/fantomas/blob/main/src/Fantomas.Core.Tests/CodePrinterHelperFunctionsTests.fs).  \nThis will give you a better understanding of how we capture events in \u0060CodePrinter\u0060.\n\n### Debugging CodePrinter\n\nOne thing that is a bit harder to grasp initially, is what is happening when you put a breakpoint in \u0060CodePrinter.fs\u0060.  \nIn \u0060CodePrinter.fs\u0060 we compose a format function that takes a \u0060Context\u0060 and returns a \u0060Context\u0060.\nWe do this by traversing the syntax tree, and when you put a breakpoint in \u0060genTypeDefn\u0060 for example:\n\n![Breakpoint in genTypeDefn](../../images/debugging-code-printer-1.png)\n\nwe are still in the process of composing the format function.  \n**The Context has not been going through our format function yet!**\n\nIf we want to debug when the \u0060Context\u0060 is traveling through the format function, we can easily, temporarily, insert an additional function to inspect the \u0060Context\u0060 content:\n\n![Breakpoint in Context -\u003E Context](../../images/debugging-code-printer-2.png)\n\nThe \u0060dumpAndContinue\u0060 helper function can be used to inspect the \u0060Context\u0060.  \nPlease remove all usages when submitting a PR \uD83D\uDE38.\n\n\n\u003Cfantomas-nav previous=\u0022./Prepare%20Context.html\u0022 next=\u0022./Formatted%20Code.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/contributors/Getting Started.html","title":"Getting started\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 3\n---\n# Getting started\n\nFantomas has a fairly straightforward setup.\n\n## Recommended workflow\n\nWe recommend the following overall workflow when developing for this repository:\n\n* Fork this repository\n* Always work in your fork\n* Always keep your fork up to date\n\nBefore updating your fork, run this command:\n\n\u0060\u0060\u0060shell\ngit remote add upstream https://github.com/fsprojects/fantomas.git\n\u0060\u0060\u0060\n\nThis will make management of multiple forks and your own work easier over time.\n\n## Updating your fork\n\nWe recommend the following commands to update your fork:\n\n\u0060\u0060\u0060shell\ngit checkout main\ngit clean -xdf\ngit fetch upstream\ngit rebase upstream/main\ngit push\n\u0060\u0060\u0060\n\nOr more succinctly:\n\n\u0060\u0060\u0060shell\ngit checkout main \u0026\u0026 git clean -xdf \u0026\u0026 git fetch upstream \u0026\u0026 git rebase upstream/main \u0026\u0026 git push\n\u0060\u0060\u0060\n\nThis will update your fork with the latest from \u0060fsprojects/fantomas\u0060 on your machine and push those updates to your remote fork.\n\n## Initial build\n\nAfter cloning the repository, you should restore the local dotnet tools and download the F# compiler source code:\n\n\u0060\u0060\u0060shell\ndotnet fsi build.fsx -p Init\n\u0060\u0060\u0060\n\nAfterwards, you can run the default build script.\nThis will build the solution, run all unit tests and do everything that the CI build does.\n\n\u0060\u0060\u0060shell\ndotnet fsi build.fsx\n\u0060\u0060\u0060\n\nAlternately, you can also run some other pipelines using \u0060-p\u0060.\nExamples:\n\n- \u0060dotnet fsi build.fsx -p FormatChanged\u0060 will format all modified files detected by \u0060git\u0060.\n- \u0060dotnet fsi build.fsx -p Docs\u0060 will serve the documentation website locally.\n-  \u0060dotnet fsi build.fsx -p EnsureRepoConfig\u0060 sets up some git repo-level configuration to ensure\nthat formatting of new code is consistent before it is pushed up to a remote repository.\n\n\u003Cfantomas-nav previous=\u0022./FSharp.html\u0022 next=\u0022./Solution%20Structure.html\u0022\u003E\u003C/fantomas-nav\u003E"},{"uri":"/fantomas/docs/contributors/FSharp.html","title":"F#\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 2\n---\n# F#\n\n## New to F#?\n\nIf you are truly brand-new to the F# language, you might want to start by reading the [F# documentation of Microsoft](https://dotnet.microsoft.com/en-us/languages/fsharp).  \nSome other great resources (in no particular order) are:\n\n- [Essential F#](https://leanpub.com/essential-fsharp)\n- [F# for Fun and Profit](https://fsharpforfunandprofit.com/)\n- [F# Fundamentals Tutorial | Learn Functional Programming | Step-by-Step Guide](https://www.youtube.com/watch?v=SvOInBxPL30)\n- [F# Foundation Slack](https://fsharp.org/guides/slack/)\n- [F# on Discord](https://discord.com/invite/R6n7c54)\n\n## Used F# features\n\nF# has a lot of nice language features, although not all of them are used in Fantomas.\nWe wish to highlight the most important ones that we use before continuing:\n\n- [Partial active patterns](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns#partial-active-patterns), these are heavily used in \u0060SourceParser.fs\u0060.\n  In short, we use the \u0060Untyped Abstract Syntax Tree\u0060 created by the F# parser, we don\u0027t use all the information in that tree to restore the source code.\n\nFor example [SynExpr.For](https://fsprojects.github.io/fantomas/reference/fsharp-compiler-syntax-synexpr.html#For), the definition looks like:\n\n\u0060\u0060\u0060fsharp\ntype SynExpr =\n    ...\n    /// F# syntax: \u0027for i = ... to ... do ...\u0027\n    | For of\n        forDebugPoint: DebugPointAtFor *\n        toDebugPoint: DebugPointAtInOrTo *\n        ident: Ident *\n        equalsRange: range option *\n        identBody: SynExpr *\n        direction: bool *\n        toBody: SynExpr *\n        doBody: SynExpr *\n        range: range\n\u0060\u0060\u0060\n\n  However, in Fantomas we have a partial active pattern that we use to easily grab the information we need from the AST.\n\u0060\u0060\u0060fsharp\nlet (|For|_|) =\n    function\n    | SynExpr.For (_, _, ident, equalsRange, e1, isUp, e2, e3, _) -\u003E Some(ident, equalsRange, e1, e2, e3, isUp)\n    | _ -\u003E None  \n\u0060\u0060\u0060\n\nNotice the underscores, we don\u0027t use the \u0060DebugPoint\u0060 info and \u0060range\u0060, so we drop that information in the result of the partial active pattern.\nWe then later use this pattern to work with the AST we need.\nExample usage in \u0060CodePrinter.fs\u0060:\n\n\u0060\u0060\u0060fsharp\nmatch expr with\n| For (ident, equalsRange, e1, e2, e3, isUp) -\u003E\n    atCurrentColumn (\n        !- \u0022for \u0022\n        \u002B\u003E genIdent ident\n        \u002B\u003E genEq SynExpr_For_Equals equalsRange\n        \u002B\u003E sepSpace\n        \u002B\u003E genExpr astContext e1\n        \u002B\u003E ifElse isUp (!- \u0022 to \u0022) (!- \u0022 downto \u0022)\n        \u002B\u003E genExpr astContext e2\n        \u002B\u003E !- \u0022 do\u0022\n        \u002B\u003E indent\n        \u002B\u003E sepNln\n        \u002B\u003E genExpr astContext e3\n        \u002B\u003E unindent\n    )\n| _ -\u003E ...\n\u0060\u0060\u0060\n\n- [Custom operators](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/operator-overloading#creating-new-operators). In F# there are some special operators like [|\u003E](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-operators.html#(|%3E)) and [\u003E\u003E](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-operators.html#(%3E%3E)).  \n\nNote that these are just functions themselves as well. Instead of specifying all the arguments after the function name, (infix) operators let you specify an argument before the operator and after. \n\nIn F#, you are able to create your own operators as well. In Fantomas, the most notable are \u0060!-\u0060 and \u0060\u002B\u003E\u0060. We will cover them later, but if you peek in \u0060CodePrinter.fs\u0060, they are heavily used there.\n\n- [Signature files](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/signature-files).\n\nIn Fantomas we use signature files to define the module boundaries. Everything that is both defined in the implementation file (the \u0060*.fs\u0060 file) and in the signature file (the \u0060*.fsi\u0060 file) is considered to be visible to other modules.\nIf a signature file is present, there is no need to specify \u0060private\u0060 in a function you don\u0027t want to be visible to other modules. Just don\u0027t add a \u0060val\u0060 entry to the signature file and it will be private automatically.\nYou can look at a signature file to get a glimpse of what the module really does.\n\n- [Type extensions](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/type-extensions).\n\nIn contrast to partial active patterns, where we want to hide some AST information, it can occur that we need to extend the type of an AST node.\nWe do this by adding a new type member to an existing Syntax tree type.\nExample in \u0060AstExtensions.fs\u0060:\n\n\u0060\u0060\u0060fsharp\ntype SynMemberFlags with\n\n    member memberFlags.FullRange: range option =\n        RangeHelpers.mergeRanges\n            [ yield! Option.toList memberFlags.Trivia.AbstractRange\n              yield! Option.toList memberFlags.Trivia.DefaultRange\n              yield! Option.toList memberFlags.Trivia.MemberRange\n              yield! Option.toList memberFlags.Trivia.OverrideRange\n              yield! Option.toList memberFlags.Trivia.StaticRange ]\n\u0060\u0060\u0060\n\nThe type \u0060SynMemberFlags\u0060 does not expose any range information, but we can extend it to do so.  \nThe \u0060.FullRange\u0060 naming convention is used to indicate that we are not satisfied by the original range or it is lacking all together.  \nDon\u0027t worry just yet about this implementation, so keep in mind that with this feature we can later use \u0060memberFlags.FullRange\u0060 on a \u0060SynMemberFlags\u0060 instance.\n\n- [Function Values](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/#function-values)\n\nThis is well-known concept in F# and for completion sake we do mention this. In F#, you can pass a function as an argument to another function.\nFantomas is full of this kind of functions, so be sure to grasp this concept before continuing.\n\n- [Tail recursion](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/recursive-functions-the-rec-keyword#tail-recursion)\n\nThere are places in the code base where we use some more advanced recursion techniques. \u0060AstTransformer.fs\u0060 is one of them.  \nA very good explanation of what happens here can be found in this [blogpost](https://www.gresearch.co.uk/blog/article/advanced-recursion-techniques-in-f/).\n\n- [Event Sourcing](https://medium.com/@dzoukr/event-sourcing-step-by-step-in-f-be808aa0ca18)\n\nWe use event sourcing to capture the instructions on how to write the new code. Instead of writing the new code directly to for example a \u0060StringBuilder\u0060, we write it to a list of events.  \nThat list of events will contain instructions like \u0060Write \u0022let\u0022\u0060, \u0060IndentBy 4\u0060, \u0060WriteLine\u0060 etc. So it is useful to have some notion of event sourcing.\n\nAlthough, it really is an implementation detail in \u0060Context.fs\u0060, think of it as writing a letter with a pen and a paper.\nWe first rehearse what we want to say, then we write the letter. Not write evey word as we are making up the letter, but write the letter as a whole once we know the content.  \nThese events are used to achieve this.\n\n\u003Cfantomas-nav previous=\u0022./index.html\u0022 next=\u0022./Getting%20Started.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/contributors/Prepare Context.html","title":"Fantomas.Core overview (1)\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 5\n---\n# Fantomas.Core overview (1)\n\nIn its simplest form, Fantomas.Core works in two major phases: prepare the context and process said context.\n\n\u003Cdiv class=\u0022mermaid text-center\u0022\u003E\ngraph TD\n    A[Prepare Context] --\u003E B\n    B[Print AST with Context] --\u003E C[Formatted code]\n    style A stroke:#338CBB,stroke-width:2px\n \u003C/div\u003E\n\nUnfortunately, both phases are not always very straight forward.  \nBut once you get hang of the first phase, you can easily understand the second phase.\n\n## Preparing the context\n\nWhen we need to format a source code file, we need to prepare the context based on the content of the input file and the configuration of the formatter.\nThe most important aspect of this phase is transforming the source code to a syntax tree. \nHowever we need to do further processing of the AST before we can simply print it out.\n\n\n\u003Cdiv class=\u0022mermaid text-center\u0022\u003E\ngraph TD\n    A[Parse AST] --\u003E B\n    B[Collect Trivia] --\u003E C\n    C[Apply configuration]\n\u003C/div\u003E\n\n### Parse AST\n\nParsing the AST is straightforward. We use the \u0060parseFile\u0060 function from \u0060Fantomas.FCS\u0060 and get back a syntax tree and diagnostic information.  \nThe diagnostic information is used to report errors and warnings. When we have errors, we stop processing the file.\n\n**Fantomas requires a valid source code to format.**\n\nIf your code has errors, the parser cannot return a complete AST which is a strict requirement to run the remaining phases.\n\n\u0060\u0060\u0060fsharp\nlet a =\n\u0060\u0060\u0060\n\nReturns a parsing error \u0060Incomplete structured construct at or before this point in binding\u0060.\nThis has \u0060FSharpDiagnosticSeverity.Error\u0060 and Fantomas will not process any code that has those.\n\nWhen there are only warnings, Fantomas will still try to process the file but will always yield a result.\n\n\u0060parseFile\u0060 takes three parameters:\n- \u0060isSignature: bool\u0060\n\nThe Syntax tree for a signature is a little different than a regular source file. The parser needs to know this and throughout the rest of the process, signature ASTs are treated differently.\n\n- \u0060sourceText: ISourceText\u0060\n\nThe input source code string is converted to an [ISourceText](https://fsprojects.github.io/fantomas/reference/fsharp-compiler-text-isourcetext.html)) internally.\n\n- \u0060defines: string list\u0060\n\nConditional compilation defines are passed to the parser. These can have an influence on the parsing process, resulting in different ASTs.\n\n\u0060\u0060\u0060fsharp\nlet a =\n    #if DEBUG\n    0\n    #else\n    1\n    #endif\n\u0060\u0060\u0060\n\nDepending on the defines \u0060[]\u0060 or \u0060[\u0022DEBUG\u0022]\u0060, the AST will be different.\nThe tree will also be created based on a single code path.\n\n### Collect Trivia\n\nA syntax tree contains almost all the information we need to format the code. \nHowever, there are three items that are either missing all together or require further processing:\n\n- Blank lines\n- Code comments\n- Conditional directives\n\nThese three items are labelled as \u0060Trivia\u0060 in Fantomas. We need to restore them because the source code originally had them, but cannot do so purely on the AST.\n\n#### Detecting trivia\n\nTrivia can however be easily detected in Fantomas. Both code comments and conditional directives are present in the AST.\nThese are stored on the file level (in [ParsedImplFileInput](https://fsprojects.github.io/fantomas/reference/fsharp-compiler-syntax-parsedimplfileinput.html) and  [ParsedSigFileInput](https://fsprojects.github.io/fantomas/reference/fsharp-compiler-syntax-parsedsigfileinput.html) in the \u0060trivia\u0060 node).\n\nIn both [ParsedImplFileInputTrivia](https://fsprojects.github.io/fantomas/reference/fsharp-compiler-syntaxtrivia-parsedimplfileinputtrivia.html) and [ParsedSigFileInputTrivia](https://fsprojects.github.io/fantomas/reference/fsharp-compiler-syntaxtrivia-parsedsigfileinputtrivia.html) we can see comments and conditional directives.\n\n\u0060\u0060\u0060fsharp\nlet a = \n   // comment b\n   c\n\u0060\u0060\u0060\n\nroughly translates to\n\n\u0060\u0060\u0060fsharp\nImplFile\n  (ParsedImplFileInput\n     (\u0022tmp.fsx\u0022, true, QualifiedNameOfFile Tmp$fsx, [], [],\n      [SynModuleOrNamespace\n         ([Tmp], false, AnonModule,\n          [Let\n             (false,\n              [SynBinding(...)],\n              tmp.fsx (1,0--3,4))], PreXmlDocEmpty, [], None, tmp.fsx (1,0--3,4),\n          { ModuleKeyword = None\n            NamespaceKeyword = None })], (false, false),\n      { ConditionalDirectives = []\n        CodeComments = [LineComment tmp.fsx (2,3--2,15)] }))\n\u0060\u0060\u0060\n\nThe AST does contain a node for the line comment, but we cannot restore it when we are processing the let binding.  \nThere is no link between the line comment and the let binding.\n\nAll trivia face this problem, so we need to process them separately.  \nWe do this in \u0060Trivia.collectTrivia\u0060.\n\nNote: blank lines are detected differently, we go over all the lines via the \u0060ISourceText\u0060.\n\n#### Assigning trivia\n\nOnce we have the trivia, we can assign them to an AST node they belong to.\nThis is one of the more tricky parts of the process.\n\nThe syntax tree exists of numerous types of nodes. There is not one discriminated union that captures all the nodes.\nTop level nodes are [SynModuleDecl](https://fsprojects.github.io/fantomas/reference/fsharp-compiler-syntax-synmoduledecl.html), expressions are [SynExpr](https://fsprojects.github.io/fantomas/reference/fsharp-compiler-syntax-synexpr.html) and so on.   \nIn Fantomas all these types do share a comment trait, they can (almost) all have trivia that belongs to them.\n\nExample:\n\n\u0060\u0060\u0060fsharp\n// comment 1\nmodule Hey\n\n// comment 2\nlet x y = // comment 3\n    // comment 4\n    y = 1\n\u0060\u0060\u0060\n\nAll these comments need to be assigned to the correct node. From the trivia point of view, the owner could be of any type.  \nThat is why we process the AST into a more generic tree structure called \u0060TriviaNode\u0060.   \nA \u0060TriviaNode\u0060 always has a type field of \u0060FsAstType\u0060 and could have child \u0060TriviaNode\u0060s.  \n\u0060FsAstType\u0060 is discriminated union that represents all the useful types of AST nodes, regardless of the concrete type they belong too.  \nYou can see in \u0060TriviaTypes\u0060 that this is a long and flat list of all the types.\n\nWe construct the root tree of \u0060TriviaNode\u0060 in \u0060ASTTransformer\u0060. There we go over the AST and create a tree of \u0060TriviaNode\u0060s.\n\n\u0060\u0060\u0060fsharp\nlet a = \n   // comment b\n   c\n\u0060\u0060\u0060\n\nwould be transformed to\n\n\u0060\u0060\u0060text\nParsedInput_: tmp.fsx (2,0--4,4)\n  SynModuleOrNamespace_AnonModule: tmp.fsx (2,0--4,4)\n    SynModuleDecl_Let: tmp.fsx (2,0--4,4)\n      SynBindingKind_Normal: tmp.fsx (2,4--4,4)\n        SynPat_Named: tmp.fsx (2,4--2,5)\n          SynIdent_: tmp.fsx (2,4--2,5)\n        SynBinding_Equals: tmp.fsx (2,6--2,7)\n        SynExpr_Ident: tmp.fsx (4,3--4,4)\n          Ident_: tmp.fsx (4,3--4,4)\n\u0060\u0060\u0060\n\nWe use this custom tree to assign the trivia to the correct node.\nTake our \u0060//comment b\u0060 for example, we will assign it to the \u0060SynExpr_Ident\u0060 node.\n\nThere are different strategies to assign the trivia to a \u0060TriviaNode\u0060, these can be found in the \u0060Trivia\u0060 module.  \nOnce we know that the code comment belongs to the ident, we store this information in a \u0060TriviaInstruction\u0060.\n\n\u0060\u0060\u0060fsharp\n{\n    Trivia = { Item = TriviaContent.Comment (Comment.CommentOnSingleLine \u0022// comment b\u0022)\n    Type = FsAstType.SynExpr_Ident\n    Range = [4,3--4,4]\n    AddBefore = true\n}\n\u0060\u0060\u0060\n\nLastly, all the instructions are stored in the \u0060Context\u0060 record.  \n\nTo summarize, the \u0060Context\u0060 initialization:\n\n\u003Cdiv class=\u0022mermaid text-center\u0022\u003E\ngraph TD\n    A[Transform AST to TriviaNode tree] --\u003E B\n    B[Capture all trivia from AST and ISourceText] --\u003E C\n    C[Assign trivia to TriviaNode and create TriviaInstructions]\n \u003C/div\u003E\n\n\u003Cfantomas-nav previous=\u0022./Solution%20Structure.html\u0022 next=\u0022./Print%20AST%20with%20Context.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/contributors/Conditional Compilation Directives.html","title":"Formatting Conditional Compilation Directives\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 8\n---\n# Formatting Conditional Compilation Directives\n\nFantomas is able to format code that contains [conditional compiler directives](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/compiler-directives#conditional-compilation-directives).  \nIn order to achieve this, Fantomas will actually format the code multiple times and merge all results afterwards.\n\n## Compilation directives and the syntax tree\n\nThe F# parser will construct a different syntax tree based on the provided compilation directives.  \nConsider the following piece of code:\n\n\u0060\u0060\u0060fsharp\nlet a =\n    #if DEBUG\n    0\n    #else\n    1\n    #endif\n\u0060\u0060\u0060\n\nWhen parsing this code without any directives, the \u0060#else\u0060 branch will be considered the active code path.  \nThe AST would be:\n\n\u0060\u0060\u0060fsharp\nImplFile\n  (ParsedImplFileInput\n     (\u0022tmp.fsx\u0022, true, QualifiedNameOfFile Tmp$fsx, [], [],\n      [SynModuleOrNamespace\n         ([Tmp], false, AnonModule,\n          [Let\n             (false,\n              [SynBinding\n                 (None, Normal, false, false, [],\n                  PreXmlDoc ((1,0), FSharp.Compiler.Xml.XmlDocCollector),\n                  SynValData\n                    (None, SynValInfo ([], SynArgInfo ([], false, None)), None),\n                  Named (SynIdent (a, None), false, None, tmp.fsx (1,4--1,5)),\n                  None, Const (Int32 1, tmp.fsx (5,4--5,5)), tmp.fsx (1,4--1,5),\n                  Yes tmp.fsx (1,0--5,5),\n                  { LetKeyword = Some tmp.fsx (1,0--1,3)\n                    EqualsRange = Some tmp.fsx (1,6--1,7) })],\n              tmp.fsx (1,0--5,5))], PreXmlDocEmpty, [], None,\n          tmp.fsx (1,0--6,10), { ModuleKeyword = None\n                                 NamespaceKeyword = None })], (false, false),\n      { ConditionalDirectives =\n         [If (Ident \u0022DEBUG\u0022, tmp.fsx (2,4--2,13)); Else tmp.fsx (4,4--4,9);\n          EndIf tmp.fsx (6,4--6,10)]\n        CodeComments = [] }))\n\u0060\u0060\u0060\n\nNotice that the right hand expression of binding \u0060a\u0060 is \u0060Const (Int32 1, ...)\u0060.\nThere is no mention of \u00600\u0060 as that code was not active and thus is not a part of the syntax tree.\n\nPassing \u0060[ \u0022DEBUG\u0022 ]\u0060 to the parser will influence the lexer. The lexer will tokenize the other code branch and take the \u0060#if DEBUG\u0060 path this time.  \nLeading to\n\n\u0060\u0060\u0060fsharp\nImplFile\n  (ParsedImplFileInput\n     (\u0022tmp.fsx\u0022, true, QualifiedNameOfFile Tmp$fsx, [], [],\n      [SynModuleOrNamespace\n         ([Tmp], false, AnonModule,\n          [Let\n             (false,\n              [SynBinding\n                 (None, Normal, false, false, [],\n                  PreXmlDoc ((1,0), FSharp.Compiler.Xml.XmlDocCollector),\n                  SynValData\n                    (None, SynValInfo ([], SynArgInfo ([], false, None)), None),\n                  Named (SynIdent (a, None), false, None, tmp.fsx (1,4--1,5)),\n                  None, Const (Int32 0, tmp.fsx (3,4--3,5)), tmp.fsx (1,4--1,5),\n                  Yes tmp.fsx (1,0--3,5),\n                  { LetKeyword = Some tmp.fsx (1,0--1,3)\n                    EqualsRange = Some tmp.fsx (1,6--1,7) })],\n              tmp.fsx (1,0--3,5))], PreXmlDocEmpty, [], None,\n          tmp.fsx (1,0--6,10), { ModuleKeyword = None\n                                 NamespaceKeyword = None })], (false, false),\n      { ConditionalDirectives =\n         [If (Ident \u0022DEBUG\u0022, tmp.fsx (2,4--2,13)); Else tmp.fsx (4,4--4,9);\n          EndIf tmp.fsx (6,4--6,10)]\n        CodeComments = [] }))\n\u0060\u0060\u0060\n\nThis tree is almost identical but the constant value is now \u0060Const (Int32 0, ...)\u0060.\n\n## Multiple trees\n\nAs the combination of directives has an influence on the tree, Fantomas first parses the tree without any directives.\nThis base tree is then being inspected for [ConditionalDirectiveTrivia](https://fsprojects.github.io/fantomas/reference/fsharp-compiler-syntaxtrivia-conditionaldirectivetrivia.html).\nWe determine the different combinations in the \u0060Defines\u0060 module.\n\n\u003Cdiv class=\u0022mermaid text-center\u0022\u003E\ngraph TD\n    A[\u0022Parse base tree\u0022] --\u003E B\n    B[\u0022Figure out all compiler define combinations\u0022] --\u003E C\n    B --\u003E D\n    C[\u0022Format tree []\u0022]\n    D[\u0022Format tree [\u0027DEBUG\u0027]\u0022]\n    C --\u003E E\n    D --\u003E E\n    E[\u0022Merge results\u0022]\n \u003C/div\u003E\n\nAs trivia is being restored in each tree, they all will have gaps in them.\n\nThe first result will look like:\n\n\u0060\u0060\u0060fsharp\nlet a =\n    #if DEBUG\n    #else\n    1\n    #endif\n\u0060\u0060\u0060\n\nand the second:\n\n\u0060\u0060\u0060fsharp\nlet a =\n    #if DEBUG\n    0\n    #else\n    #endif\n\u0060\u0060\u0060\n\n## Merging the trees\n\nOnce every tree is formatted, we chop each file into fragments.\nA fragment is everything between a conditional directive \u0060#if | #else | #endif\u0060 or an actual directive.  \nEach result should have the same amount of fragments before we can merge them together.\nIf this is not the case, it means that somewhere a trivia was not properly restored.\n\nIf the number of fragments add up in each tree, then we merge two trees by reducing both lists and comparing each fragment.  \nWe always take the longest fragment and thus picking the active code.\n\n\u0060\u0060\u0060fsharp\n// fragments of []\n[ \u0022let a =\u0022; \u0022#if DEBUG\u0022; \u0022\u0022; \u0022#else\u0022; \u00221\u0022; \u0022#endif\u0022 ]\n\n// fragments of [ \u0022DEBUG\u0022 ]\n[ \u0022let a =\u0022; \u0022#if DEBUG\u0022; \u00220\u0022; \u0022#else\u0022; \u0022\u0022; \u0022#endif\u0022 ]\n\u0060\u0060\u0060\n\nAfter merging:\n\u0060\u0060\u0060fsharp\n[ \u0022let a =\u0022; \u0022#if DEBUG\u0022; \u00220\u0022; \u0022#else\u0022; \u00221\u0022; \u0022#endif\u0022 ]\n\u0060\u0060\u0060\n\n\u003Cfantomas-nav previous=\u0022./Formatted%20Code.html\u0022 next=\u0022./How%20Can%20I%20Contribute.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/contributors/Solution Structure.html","title":"Solution structure\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 4\n---\n# Solution structure\n\nFantomas has a modular project structure.  \nThe parser (\u0060Fantomas.FCS\u0060), the core library (\u0060Fantomas.Core\u0060) and the command line application (\u0060fantomas\u0060) are the main components of the solution.\n\n\u003Cdiv class=\u0022mermaid text-center\u0022\u003E\ngraph TD\n    A[Fantomas.FCS] --\u003E B\n    B[Fantomas.Core] --\u003E C[Fantomas]\n    B --\u003E D[Fantomas.Benchmarks]\n    B --\u003E E[Fantomas.Core.Tests]\n    C --\u003E F[Fantomas.Tests]\n    G[Fantomas.Client]\n \u003C/div\u003E\n\n## Fantomas.FCS\n\nThis is a very custom fork of the F# compiler. We only expose a single parse function to construct the untyped syntax tree.\nWe achieve this by taking the files necessary to compile the F# parser from source (via custom code in a \u0060Fun.Build\u0060 pipeline).\nThis limits the dependency footprint that our compiler has, compared to the official [F# compiler NuGet package](https://www.nuget.org/packages/FSharp.Compiler.Service).\n\nNote that the AST returned by \u0060Fantomas.FCS\u0060 looks identical to what the official F# compiler returns. \nHowever, the AST is not binary compatible. It is most likely that Fantomas contains a newer version of the Syntax tree than the official F# compiler.\n\n## Fantomas.Core\n\nThe heart of Fantomas is the core library. It contains the core logic reconstructing source code from the AST.\nFantomas can be used as a library, see \u0060CodeFormatter.fsi\u0060 to learn what APIs are exposed.\n\n## Fantomas\n\nThe command line application is the main entry point of the solution.  \nIt exposes the core functionality and also takes care of \u0060.editorconfig\u0060 and \u0060.fantomasignore\u0060 files.\n\n## Fantomas.Benchmarks\n\nA [BenchmarkDotNet](https://benchmarkdotnet.org/articles/overview.html) project used to measure the performance of the core library.\nWe format a fixed revision of \u0060CodePrinter.fs\u0060 as part of our CI process, to detect potential regressions.\n\n## Fantomas.Client\n\nA standalone library project that editors can use to interact with the \u0060fantomas\u0060 commandline application.\nEditors do not use \u0060Fantomas.Core\u0060, instead they use the \u0060Fantomas.Client\u0060 library to connect to a \u0060fantomas\u0060 dotnet tool.\nThis allows end-users to bring their \u0022own version\u0022 of Fantomas.\nThis selected version could then later be re-used to verify if all files were formatted in a CI scenario.\n\n## Fantomas.Core.Tests\n\nA suite of unit tests that target the core formatting functionalities of \u0060Fantomas.Core\u0060.\n\n## Fantomas.Tests\n\nA suite of end-to-end tests that run the actual \u0060fantomas\u0060 command line application.\n\n\u003Cfantomas-nav previous=\u0022./Getting%20Started.html\u0022 next=\u0022./Prepare%20Context.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/contributors/Pull request ground rules.html","title":"Pull request ground rules\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 11\n---\n# Pull request ground rules\n\nWe expect some things from code changes.\nIn general, changes should be made as consistent to the current code base as possible.\nDon\u0027t introduce unnecessary new concepts and try and change as little code as possible to achieve your goal.\n\nAlways start with the mindset that you are going to introduce a change that might have an impact on how the tool behaves.\nCapture this change first in a unit test. Set your expectations in the assert part of the test before touching anything.\nThis project is very well suited for [Test-driven development](https://en.wikipedia.org/wiki/Test-driven_development) and that should be the goal.\n\nTypical unit test template:\n\n\u0060\u0060\u0060fsharp\n[\u003CTest\u003E]\nlet \u0060\u0060my new test\u0060\u0060 () =\n    formatSourceString false \u0022\u0022\u0022\nlet myInput =     42\n\u0022\u0022\u0022  config\n    |\u003E prepend newline\n    |\u003E should equal \u0022\u0022\u0022\nlet myInput = 42\n\u0022\u0022\u0022\n\u0060\u0060\u0060\n\nThe vast majority of the tests use the template listed above. Only deviate from this when necessary.\nTry and find a suitable file in \u0060Fantomas.Core.Tests\u0060, or introduce a new file.\n\nA new test file should look like:\n\n\u0060\u0060\u0060fsharp\nmodule Fantomas.Core.Tests.MyNewConceptTests\n\nopen NUnit.Framework\nopen FsUnit\nopen Fantomas.Core.Tests.TestHelper\n\n// add tests here...\n\u0060\u0060\u0060\n\nFilename: \u0060MyNewConceptTests.fs\u0060.\n\nWhen developing a new feature, add new tests to cover all code paths.\n\nIf you come across an issue, which can\u0027t be reproduced with the latest version of Fantomas but is still open, please submit a regression test.\nThat way, we can ensure the issue stays fixed after closing it.\n\n## Guidelines\n\n### Target branch\n\nPlease always rebase your code on the targeted branch.\nTo keep your fork up to date, run this command:\n\u003E git remote add upstream https://github.com/fsprojects/fantomas.git\n\nUpdating your fork:\n\n\u003E git checkout main \u0026\u0026 git fetch upstream \u0026\u0026 git rebase upstream/main \u0026\u0026 git push\n\n### Unit test\n\n- Unit test names should start with a lowercase letter.\n- When creating a test that is linked to a GitHub issue, add the number at the back with a comma, as in the following:\n\n\u0060\u0060\u0060fsharp\n[\u003CTest\u003E]\nlet \u0060\u0060preserve compile directive between piped functions, 512\u0060\u0060 () = ...\n\u0060\u0060\u0060\nYou don\u0027t need to repeat this number for tests that are deviations from the original report problem. \n\n### Verify signature files\n\nVerify if the change you are making should also apply to signature files (\u0060*.fsi\u0060).\n\n### Verify slight variations\n\n- Check if you need additional tests to cope with a different combination of settings.\n- Check if you need additional tests to cope with a different combination of defines (\u0060#if DEBUG\u0060, ...).\n\n### Documentation\n\nWrite/update documentation when necessary.  \nYou can find instructions on how to run the documentation locally in the [docs/.README.md](https://github.com/fsprojects/fantomas/blob/main/docs/.README.md) file.\n\n### Pull request title\n\n- Give your PR a meaningful title. Make sure it covers the change you are introducing in Fantomas.\n\n  For example:\n  *\u0022Fix bug 1404\u0022* is a poor title as it does not tell the maintainers what changed in the codebase.  \n  *\u0022Don\u0027t double unindent when record has an access modifier\u0022* is better as it informs us what exactly has changed.\n- Add a link to the issue you are solving by using [a keyword](https://docs.github.com/en/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword) in the PR description.  \n  *\u0022Fixes #1404\u0022* does the trick quite well. GitHub will automatically close the issue if you used the correct wording.\n\n  ![Linked issue](../../images/github-linked-issue.png)\n\n  Please verify your issue is linked. ([GitHub documentation](https://docs.github.com/en/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword))\n\n- Not mandatory, but when fixing a bug consider using \u0060fix-\u003Cissue-number\u003E\u0060 as the git branch name.  \n  For example, \u0060git checkout -b fix-1404\u0060.\n\n### Format your changes\n\n- Code should be formatted to our standard style, using either \u0060dotnet fsi build.fsx -p FormatAll\u0060 which works on all files, or\n  \u0060dotnet fsi build.fsx -p FormatChanged\u0060 to just change the files in git.\n    - If you forget, there\u0027s a git \u0060pre-commit\u0060 script that will run this for you, make sure to run \u0060dotnet fsi build.fsx -p EnsureRepoConfig\u0060 to set that hook up.\n\n### Changelog\n\n- Add an entry to the \u0060CHANGELOG.md\u0060 in the \u0060Unreleased\u0060 section based on what kind of change your change is. Follow the guidelines at [KeepAChangelog](https://keepachangelog.com/en/1.0.0/#how) to make your message relevant to future readers.\n    - If you\u0027re not sure what Changelog section your change belongs to, start with \u0060Changed\u0060 and ask for clarification in your Pull Request\n    - If there\u0027s not an \u0060Unreleased\u0060 section in the \u0060CHANGELOG.md\u0060, create one at the top above the most recent version like so:\n\n      \u0060\u0060\u0060markdown\n      ## [Unreleased]\n  \n      ### Changed\n      * Your new feature goes here\n  \n      ## [4.7.4] - 2022-02-10\n  \n      ### Added\n      * Awesome feature number one\n      \u0060\u0060\u0060\n\n    - When fixing a \u0060bug (soundness)\u0060, add a line in the following format to \u0060Fixed\u0060:\n      \u0060* \u003COriginal GitHub issue title\u003E [#issue-number](https://github.com/fsprojects/fantomas/issues/issue-number)\u0060.\n      For example, \u0060* Spaces are lost in multi range expression. [#2071](https://github.com/fsprojects/fantomas/issues/2071)\u0060.\n      Do the same, if you fixed a \u0060bug (stylistic)\u0060 that is not related to any style guide.\n    - When fixing a \u0060bug (stylistic)\u0060, add a line in the following format to \u0060Changed\u0060\n      \u0060Update style of xyz. [#issue-number](https://github.com/fsprojects/fantomas/issues/issue-number)\u0060\n    - For example, \u0060* Update style of lambda argument. [#1871](https://github.com/fsprojects/fantomas/issues/1871)\u0060.\n\n### Run a local build\n\nFinally, make sure to run \u0060dotnet fsi build.fsx\u0060. Among other things, this will check the format of the code and will tell you, if\nyour changes caused any tests to fail.\n\n### Small steps\n\nIt is better to create a draft pull request with some initial small changes, and engage conversation, than to spend a lot of effort on a large pull request that was never discussed.\nSomeone might be able to warn you in advance that your change will have wide implications for the rest of Fantomas, or might be able to point you in the right direction.\nHowever, this can only happen if you discuss your proposed changes early and often.\nIt\u0027s often better to check *before* contributing that you\u0027re setting off on the right path.\n\n## Fixing style guide inconsistencies\n\nFantomas tries to keep up with the style guides, but as these are living documents, it can occur that something is listed in the style that Fantomas is not respecting.\nIn this case, please create an issue using our [online tool](https://fsprojects.github.io/fantomas-tools/#/).\nCopy the code snippet from the guide and add a link to the section of the guide that is not being respected.\nThe maintainers will then add the \u0060bug (stylistic)\u0060 to confirm the bug is fixable in Fantomas. In most cases, it may seem obvious that the case can be fixed.\nHowever, in the past there have been changes to the style guide that Fantomas could not implement for technical reasons: Fantomas can only implement rules based on information entirely contained within the untyped syntax tree.\n\n### Target the next minor or major branch\n\nWhen fixing a stylistic issue, please ask the maintainers what branch should be targeted. The rule of thumb is that the \u0060main\u0060 branch is used for fixing \u0060bug (soundness)\u0060 and will be used for revision releases.\nStrive to ensure that end users can always update to the latest patch revision of their current minor or major without fear.\n\nA user should only need to deal with style changes when they have explicitly [chosen to upgrade](https://github.com/fsprojects/fantomas/blob/main/docs/Documentation.md#updating-to-a-new-fantomas-version) to a new minor or major version.\nIn case no major or minor branch was created yet, please reach out to the maintainers.\nThe maintainers will frequently rebase this branch on top of the main branch and release alpha/beta packages accordingly.\n\n\u003Cfantomas-nav previous=\u0022./The%20Missing%20Comment.html\u0022 next=\u0022./Releases.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/contributors/Formatted Code.html","title":"Fantomas.Core overview (3)\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 7\n---\n# Fantomas.Core overview (3)\n\nAfter the \u0060Context\u0060 travelled throught the composed \u0060CodePrinter\u0060 function, all events are captured.  \nThese can be converted to a string of formatted code.\n\n\u003Cdiv class=\u0022mermaid text-center\u0022\u003E\ngraph TD\n    A[Prepare Context] --\u003E B\n    B[Print AST with Context] --\u003E C[Formatted code]\n    style C stroke:#338CBB,stroke-width:2px\n \u003C/div\u003E\n\n## Post processing\n\nAs a final step in the process, we validate the result of the code generation.  \nWe do this by parsing the existing code and investigating the fsharp diagnostics.\nWhen there are any warnings or errors, we will throw an exception.\nSome warnings are are allowed as they indicate problems that were most likely already present in the input code.\nSee \u0060Validation.fs\u0060 for more details.\n\n\u003Cfantomas-nav previous=\u0022./Print%20AST%20with%20Context.html\u0022 next=\u0022./Conditional%20Compilation%20Directives.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/contributors/Index.html","title":"Contributors\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 1\n---\n# Contributors\n\n\u003E \u201CIt\u0027s a dangerous business, Frodo, going out of your door,\u0022 he used to say. \u0022You step into the Road, and if you don\u0027t keep your feet, there is no knowing where you might be swept off to. \u2015 J.R.R. Tolkien, The Fellowship of the Ring\n\nFantomas is a project that has its roots deeply nested in the F# compiler. This can be an overwhelming experience at first, and it might even make you nervous about contributing in the first place.\nFear not: once you get the hang of it, things are less complicated than they seem.\n\nIn short, Fantomas is a source-code-to-source-code compiler. It will transform the text in the source code to an intermediate format and transform that again to source code.\nIt uses the F# Compiler to do this. The parser from the F# compiler will be used to create an [UnTyped Abstract Syntax](https://fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree.html) tree (or \u0022AST\u0022).\nThe AST is then reprinted in \u0060CodePrinter.fs\u0060: once the whole tree is traversed, the formatted code can be constructed.\n\nIn this section of our documentation, we wish to teach you everything you need to know to contribute to Fantomas.\nEvery F# developer should be able to understand the project, even the ones new to the language.\nThe best is yet to come!\n\nPS: Don\u0027t hesitate to open [an issue](https://github.com/fsprojects/fantomas/issues/new/choose) if you have any questions. \nOr if something isn\u0027t all that clear. Our goal is to make this documentation as complete as possible\uD83C\uDF89!\n\n## Visual Studio Issue\n\nThere is currently [a known issue](https://github.com/fsprojects/fantomas/issues/2447) when loading the \u0060fantomas\u0060 solution in Visual Studio that prevents the solution from being able to build properly. This is due to an issue in the \u0060Ionide.KeepAChangelog\u0060 build step (tracking the issue [here](https://github.com/ionide/KeepAChangelog/issues/8)).\n\nTo workaround this in the meantime, you\u0027ll need to comment out the references to \u0060Ionide.KeepAChangelog.Tasks\u0060 in \u0060Directory.Build.props\u0060 and all of the \u0060packages.lock.json\u0060 files, and then run \u0060dotnet restore\u0060. **Please be careful not to include these changes when submitting a PR!**\n\n\u003Cfantomas-nav next=\u0022./FSharp.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/contributors/Releases.html","title":"Releases\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 12\n---\n# Releases\n\nReleases in Fantomas are not automated and require some manual steps by the maintainers.\n\n## Preparation\n\nThe [CHANGELOG.md](https://github.com/fsprojects/fantomas/blob/main/CHANGELOG.md) needs a new header with an official release tag:\n\n\u0060\u0060\u0060md\n## [5.1.0] - 2022-11-04\n\u0060\u0060\u0060\n\nIt is custom to have the next version merged into the \u0060main\u0060 branch and locally publish from there.\n\nVerify that all recent PRs and closed issues are listed in the changelog. Normally, this should be ok as we require a changelog entry before we merge a PR.\n\n## NuGet push\n\nTo publish the new versions to NuGet:\n\n\u003E dotnet fsi build.fsx --push\n\nThe \u0060--push\u0060 will try and publish the \u0060*.nupkg\u0060 files created by the build in the \u0060bin\u0060 folder.\n\u0060Fantomas.Client\u0060 will be excluded and requires a specific pipeline to publish.\n\nThe pipeline does assume that the \u0060NUGET_KEY\u0060 environment variable is set with a valid NuGet key.\n\n## GitHub release\n\nA new GitHub release entry should be created for official versions. This will notify users who have subscribed to releases.  \nIn the past some alpha or beta releases have had a GitHub release, it depends on the occasion.\n\n### Tag\n\nCreate a new tag based on the main branch. The assumption is that the \u0060CHANGELOG\u0060 file contains the tag version you are about to create.\n\n### Release title\n\nFor a revision release you can use the current date (example: \u0060October 13th Release\u0060), for a minor or major releas pick the month name (example: \u0060September\u0060).\n\n### Description\n\nSome parts of the description are fixed, some depend on the occasions:\n\n\u0060\u0060\u0060md\n# Title\n\n\u003C!-- Optional intro paragraph  --\u003E\n\n\u003C!-- Copy the sections of the changelog --\u003E\n\n\u003C!-- Optional special thanks --\u003E\nSpecial thanks to @x, @y and @z!\n\n\u003C!-- Link to published version on NuGet --\u003E\n[https://www.nuget.org/packages/fantomas/5.0.4](https://www.nuget.org/packages/fantomas/5.0.4)\n\u0060\u0060\u0060\n\nThe format of the title is \u0060# version\u0060 (example: \u0060# 5.0.5\u0060). This differs from the notation used in the changelog file!  \nFor minors and majors a codename (inside a \u0060\u003Csub\u003E\u0060 tag) is used. All codenames so far have been song titles by the band Ghost (example \u0060# 5.1.0 \u003Csub\u003EKaisarion\u003C/sub\u003E - 11/2022\u0060).  \nWith the exception of \u0060v5, \u0022Get Back\u0022\u0060.\n\nThe list of people to thank is compiled by cross referencing the changelog entries. The author of the GitHub release is omitted.  \nDon\u0027t be shy to include other names of people who have contributed in alternative ways when the occasion calls for it.\n\n### Artifacts\n\nUpload the \u0060*.nupkg\u0060 files to the release artifacts.\n\n## Spread the word\n\nShare the newly created release on our Discord server in the \u0060#announcements\u0060 channel.  \nOptionally share (minor or major) releases on other social media. \n\n\u003Cfantomas-nav previous=\u0022./Pull%20request%20ground%20rules.html\u0022 next=\u0022./Glossary.html\u0022\u003E\u003C/fantomas-nav\u003E"},{"uri":"/fantomas/docs/contributors/The Missing Comment.html","title":"The Missing Comment\n","content":"---\ncategory: Contributors\ncategoryindex: 2\nindex: 10\n---\n# The Missing Comment\n\nCode comments can literally exist between every single F# token. I\u0027m looking at you block comment \u0060(* ... *)\u0060.  \nAs explained in [Detecting trivia](./Prepare%20Context.html#Detecting-trivia), we need to do quite some processing to restore code comments.  \nIn this guide, we would like to give you seven tips to restore a missing comment!\n\n## Breathe\n\nWe understand it very well that losing a code comment after formatting can be extremely frustrating.  \nThere is no easy fix that will solve all the missing comments overnight. Each case is very individual and can be complex to solve.  \nMay these steps help towards fixing your problem!\n\n## Isolate the problem\n\nBefore we can commence our murder mystery, it is best to narrow down our problem space.\n\nExample ([#2490](https://github.com/fsprojects/fantomas/issues/2490)):\n\n\u0060\u0060\u0060fsharp\nlet (* this comment disappears after formatting *) a = []\n\ntype A = \n    {\n        X : int\n        ...\n    }\n\nwhile true do ()\n\u0060\u0060\u0060\n\nUsing the [online tool](https://fsprojects.github.io/fantomas-tools/#/fantomas/preview), we can remove any code that isn\u0027t relevant.\nThe \u0060type\u0060 and \u0060while\u0060 code can be trimmed and the problem still exists.\n\n## Check the syntax tree\n\nEvery code comment should be present on the root level of the syntax tree.\n[ParsedImplFileInputTrivia](../../reference/fsharp-compiler-syntaxtrivia-parsedimplfileinputtrivia.html) or [ParsedSigFileInputTrivia](../../reference/fsharp-compiler-syntaxtrivia-parsedsigfileinputtrivia.html) should contain the comment.\n\n\u0060\u0060\u0060fsharp\nImplFile\n  (ParsedImplFileInput\n     (\u0022tmp.fsx\u0022, true, QualifiedNameOfFile Tmp$fsx, [], [],\n      [ ... ], (false, false),\n      { ConditionalDirectives = []\n        CodeComments = [BlockComment tmp.fsx (1,4--1,50)] }))\n\u0060\u0060\u0060\n\nIf the comment is not there this means the F# lexer and parser didn\u0027t pick up the comment. In the unlikely event this happened, this should be fixed first over at [dotnet/fsharp](https://github.com/dotnet/fsharp).\n\n## Was the comment detected as trivia?\n\nFantomas grabs the comments straight from the syntax tree, and transforms them as \u0060Trivia\u0060.  \nThis is a fairly straightforward process, and you can easily visually inspect this using the [online tool](https://fsprojects.github.io/fantomas-tools/#/trivia).\n\n![Trivia in online tool](../../images/online-tool-trivia-1.png)\n\nIf your comment does not show up there, it means there is a problem between getting the information from the syntax tree and constructing the \u0060Trivia\u0060 in \u0060Trivia.fs\u0060.\n\n## Was the trivia assigned to a trivia node?\n\nThe \u0060Trivia\u0060 needs to be assigned to a \u0060TriviaNode\u0060 to be stored in the \u0060Context\u0060.  \nUsing the center tab in the tool, we can see the tree structure of all available \u0060TriviaNodes\u0060.\n\n![Root node in online tool](../../images/online-tool-trivia-2.png)\n\nChoosing the best suitable node can be quite tricky, there are different strategies for different \u0060TriviaTypes\u0060.  \nIn this example \u0060SynBindingKind_Normal\u0060 and \u0060SynPat_Named\u0060 are good candidates as they appear right after the comment.  \nOnce the \u0060Trivia\u0060 is assigned to a \u0060TriviaNode\u0060, a \u0060TriviaInstruction\u0060 will be created. This is the link between them and is what will be stored in the \u0060Context\u0060.\n\nThe left-most tab in the tool shows us the result of the assigment:\n\n![Trivia Instructions in online tool](../../images/online-tool-trivia-3.png)\n\nIn this example, at the time of writing, there are no \u0060TriviaInstructions\u0060. This means the assignment in \u0060Trivia.fs\u0060 failed and we would need to investigate why.\n\n## Was the trivia assigned to the best possible node?\n\nSometimes the selected \u0060TriviaNode\u0060 isn\u0027t really the best possible candidate.\nIn [#640](https://github.com/fsprojects/fantomas/issues/640), the \u0060Directive\u0060 trivia are assigned to \u0060SynBindingKind_Normal\u0060.\n\n![Wrong node assignment in online tool](../../images/online-tool-trivia-4.png)\n\nNotice that \u0060SynBindingKind_Normal\u0060 starts at line \u00606\u0060, while the \u0060Trivia\u0060 is wrapped around the \u0060inline\u0060 keyword on line \u00604\u0060.  \nIt would be ideal if we could use the \u0060inline\u0060 keyword as a \u0060TriviaNode\u0060, but looking at the tree, it doesn\u0027t appear to be present.\nWhy is that? Well, the syntax tree does, at the time of writing, not provide a \u0060range\u0060 for the keyword.  \nThis would be a great addition as to [SyntaxTreeTrivia](../../reference/fsharp-compiler-syntaxtrivia.html), and can be done by submitting a pull request to [dotnet/fsharp](https://github.com/dotnet/fsharp).\n\n## Printing the TriviaInstruction\n\nThe last piece of the puzzle is printing the actual \u0060TriviaInstruction\u0060 in \u0060CodePrinter\u0060.\nIf everything up to this point went well, and the comment is still missing after formatting, it means it was not printed.\n\nEvery \u0060TriviaInstruction\u0060 has a type (\u0060FsAstType\u0060) and a \u0060range\u0060. The \u0060range\u0060 is taken from an actual AST node, so when we encounter this \u0060range\u0060 in \u0060CodePrinter\u0060, we need to act upon it.  \nWe typically do this by calling \u0060genTriviaFor\u0060, passing down the \u0060type\u0060, the \u0060range\u0060 and a function \u0060f\u0060 that should be composed in between.\n\nExample:\n\n\u0060\u0060\u0060fsharp\ngenTriviaFor Ident_ (* : FsAstType *) ident.idRange (* range : *) genIdent (* : Context -\u003E Context *) \n\u0060\u0060\u0060\n\nIf we look at the definition of \u0060genTriviaFor\u0060:\n\n\u0060\u0060\u0060fsharp\nand genTriviaFor (mainNodeName: FsAstType) (range: Range) f ctx =\n    (enterNodeFor mainNodeName range \u002B\u003E f \u002B\u003E leaveNodeFor mainNodeName range) ctx\n\u0060\u0060\u0060\n\nWe can derive that the composition will be as follows:\n\n\u0060\u0060\u0060fsharp\nenterNodeFor Ident_ ident.idRange\n\u002B\u003E genIdent\n\u002B\u003E leaveNodeFor Ident_ ident.idRange\n\u0060\u0060\u0060\n\n\u0060enterNodeFor\u0060 and \u0060leaveNodeFor\u0060 will print the \u0060TriviaInstruction\u0060 it finds for the \u0060range\u0060 and \u0060type\u0060 inputs in the \u0060Context\u0060.\n\n\u003Cfantomas-nav previous=\u0022./How%20Can%20I%20Contribute.html\u0022 next=\u0022./Pull%20request%20ground%20rules.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/end-users/IgnoreFiles.html","title":"Ignore Files\n","content":"---\ncategory: End-users\ncategoryindex: 1\nindex: 4\n---\n# Ignore Files \n\n*starting version 4.1*\n\nTo exclude files from formatting, create a \u0060.fantomasignore\u0060 file in the root of your project.  \n\u0060.fantomasignore\u0060 uses [gitignore](https://git-scm.com/docs/gitignore) syntax (processed via [Ignore](https://github.com/goelhardik/ignore)).  \nIgnored files will be picked up by the [Fantomas command line tool](https://www.nuget.org/packages/fantomas/).\n\nExclusion applies both to formatting and the format checking.\n\n\u0060\u0060\u0060\n# Ignore Fable files\n.fable/\n\n# Ignore script files\n*.fsx\n\u0060\u0060\u0060\n\nNote that Fantomas only searches for a \u0060.fantomasignore\u0060 file in or above its current working directory, if one exists; unlike Git, it does not traverse the filesystem for each input file to find an appropriate ignore file.\n(This is not true of the Fantomas daemon. The daemon can\u0027t rely on being invoked from the right place, and indeed there may not even be a well-defined notion of \u0022right place\u0022 for the formatting tasks the daemon is required to perform, so it does search the filesystem for every file individually.)\n\nAlso note that if you are less familiar with \u0060.gitignore\u0060, \u0060.gitgnore\u0060 processes everything using Unix slashes \u0060/\u0060.  \nWindows slashes \u0060 \\ \u0060 will not work correctly. See [official Git documentation](https://git-scm.com/docs/gitignore#_pattern_format) for more info.\n\n## Great for gradual adoption\n\nIt is not always possible to format all code from the moment you start using Fantomas. Your team might be working on a lot of features and the initial format can lead to a hugh set of changes in source control.  \nThe \u0060.fantomasignore\u0060 file can help you to introduce Fantomas **bit by bit** to a new code base.  \nA good example of this is [dotnet/fsharp](https://github.com/dotnet/fsharp/blob/main/.fantomasignore), the maintainers initially only formatted signature files and are formatting more code over time.\n\n## A storm in a teacup\n\nFantomas is not perfect, there are open issues and depending on what shenanigans you have in your code you might at some point encounter a bug \uD83D\uDE05\uD83D\uDE48.  \nBefore you\u0027ve decided that Fantomas is not for you, you might want to use a \u0060.fantomasignore\u0060 file to overcome that one problem.\nIn the past people have been quick to judge that the tool cannot be used, however, through a different looking glass Fantomas maybe did format *99%* of your code correctly.\n\n\u003Cfantomas-nav previous=\u0022./Configuration.html\u0022 next=\u0022./FormattingCheck.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/end-users/VSCode.html","title":"Visual Studio Code\n","content":"---\ncategory: End-users\ncategoryindex: 1\nindex: 8\n---\n# Visual Studio Code\nThe recommended way to use Fantomas in Visual Studio Code is by using the [Ionide plugin](http://ionide.io/). Fantomas is integrated in [FSAutoComplete](https://github.com/fsharp/FsAutoComplete/) which is the language server used by Ionide.  \nMake sure Ionide is set to the default formatter inside \u0060settings.json\u0060 :\n\n\u0060\u0060\u0060\n  \u0022[fsharp]\u0022: {\n    \u0022editor.formatOnSave\u0022: true,\n    \u0022editor.defaultFormatter\u0022: \u0022Ionide.Ionide-fsharp\u0022\n  }\n\u0060\u0060\u0060\n\n### Fantomas version detection used by Fantomas.Client\n\n*starting version 4.6*\n\nFantomas version detection will try and find a compatible version in the following order:\n\n1. The version of Fantomas used by your local project. This is the fantomas version displayed when you run \u0060dotnet tool list\u0060 inside the project folder.  \n2. Your global Fantomas version. If fantomas was installed with \u0060dotnet tool install fantomas -g\u0060. You can see your global installations with \u0060dotnet tool list -g\u0060.  \n3. Executable named \u0060fantomas\u0060 found in your PATH.\n\n\u003Cfantomas-nav previous=\u0022./VisualStudio.html\u0022 next=\u0022./GeneratingCode.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/end-users/Configuration.html","title":"Configuration\n","content":"(**\n---\ncategory: End-users\ncategoryindex: 1\nindex: 3\n---\n*)\n\n(**\n# Configuration\nFantomas ships with a limited series of options.\nThese can be stored in an [.editorconfig](https://editorconfig.org/) file and will be picked up automatically by the\ncommandline.  \nYour IDE should respect your settings, however the implementation of that is editor specific. Setting the configuration via\nUI might be available depending on the IDE.\n*)\n\n(**\n## Usage\nInside .editorconfig you can specify the file extension and code location to be use per config:\n\u0060\u0060\u0060\n[*.fs]\nfsharp_space_before_uppercase_invocation = true\n\n#\\ Write a comment by starting the line with a \u0027#\u0027\n[*.{fs,fsx,fsi}]\nfsharp_bar_before_discriminated_union_declaration = true\n\n#\\ Apply specific settings for a targeted subfolder\n[src/Elmish/View.fs]\nfsharp_multiline_block_brackets_on_same_column = true\nfsharp_experimental_stroustrup_style = true\n\u0060\u0060\u0060\n*)\n\n(**\n## Trying your settings via the online tool\nYou can quickly try your settings via the \u003Ca href=\u0022https://fsprojects.github.io/fantomas-tools/#/fantomas/preview\u0022 target=\u0022_blank\u0022\u003Eonline tool\u003C/a\u003E.\n\n\u003Cimg src=\u0022{{root}}/online_tool_usage.gif\u0022 alt=\u0022drawing\u0022 width=\u0022100%\u0022/\u003E\n*)\n\n#r \u0022nuget: Fantomas.Core, 5.*\u0022\n\nopen Fantomas.Core.FormatConfig\nopen Fantomas.Core\n\nlet formatCode input configIndent =\n    CodeFormatter.FormatDocumentAsync(false, input, configIndent)\n    |\u003E Async.RunSynchronously\n\n(**\n## Settings recommendations\nFantomas ships with a series of settings that you can use freely depending  on your case.  \nHowever, there are settings that we do not recommend and generally should not be used.\n\u003Cp\u003E\u003Cfantomas-setting-icon type=\u0022green\u0022\u003E\u003C/fantomas-setting-icon\u003E\u003Cstrong\u003ESafe to change:\u003C/strong\u003E Settings that aren\u0027t attached to any guidelines. Depending on your team or your own preferences, feel free to change these as it\u0027s been agreed on the codebase, however, you can always use it\u0027s defaults.\u003C/p\u003E\n\u003Cp\u003E\u003Cfantomas-setting-icon type=\u0022orange\u0022\u003E\u003C/fantomas-setting-icon\u003E\u003Cstrong\u003EUse with caution:\u003C/strong\u003E Settings where it is not recommended to change the default value. They might lead to incomplete results.\u003C/p\u003E\n\u003Cp\u003E\u003Cfantomas-setting-icon type=\u0022red\u0022\u003E\u003C/fantomas-setting-icon\u003E\u003Cstrong\u003EDo not use:\u003C/strong\u003E Settings that don\u0027t follow any guidelines.\u003C/p\u003E\n\u003Cp\u003E\u003Cfantomas-setting-icon-gresearch\u003E\u003C/fantomas-setting-icon-gresearch\u003E\u003Cstrong\u003EG-Research:\u003C/strong\u003E G-Research styling guide. If you use one of these, for consistency reasons you should use all of them.\u003C/p\u003E\n*)\n\n(**\n## Auxiliary settings\n\n\u003Cfantomas-setting name=\u0022indent_size\u0022 orange\u003E\u003C/fantomas-setting\u003E\n\n\u0060 indent_size\u0060 has to be between 1 and 10.\n\nThis preference sets the indentation\nThe common values are 2 and 4.  \nThe same indentation is ensured to be consistent in a source file.\n\nDefault = 4.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let inline selectRandom (f: _ []) =\n      let r = random 1.0\n\n      let rec find =\n          function\n          | 0 -\u003E fst f.[0]\n          | n when r \u003C snd f.[n] -\u003E fst f.[n]\n          | n -\u003E find (n - 1)\n\n      find \u003C| f.Length - 1\n    \u0022\u0022\u0022\n    { FormatConfig.Default with IndentSize = 2 }\n(*** include-it ***)\n(**\n\u003Cfantomas-setting name=\u0022max_line_length\u0022 green\u003E\u003C/fantomas-setting\u003E\n\n\u0060max_line_length\u0060 has to be an integer greater or equal to 60.  \nThis preference sets the column where we break F# constructs into new lines.\n\nDefault = 120.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    match myValue with\n    | Some foo -\u003E someLongFunctionNameThatWillTakeFooAndReturnsUnit foo\n    | None -\u003E printfn \u0022nothing\u0022\n    \u0022\u0022\u0022\n    { FormatConfig.Default with MaxLineLength = 60 }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022end_of_line\u0022 green\u003E\u003C/fantomas-setting\u003E\n\n\u0060end_of_line\u0060 determines the newline character, \u0060lf\u0060 will add \u0060\\n\u0060 where \u0060crlf\u0060 will add \u0060\\r\\n\u0060.  \n\u0060cr\u0060 is not supported by the F# language spec.  \nIf not set by the user, the default value is determined by \u0060System.Environment.NewLine\u0060.\n*)\n\n(**\n\u003Cfantomas-setting name=\u0022insert_final_newline\u0022 orange\u003E\u003C/fantomas-setting\u003E\n\nAdds a final newline character at the end of the file.  \n\u003Ca href=\u0022https://stackoverflow.com/questions/729692/why-should-text-files-end-with-a-newline\u0022 target=\u0022_blank\u0022\u003EWhy should text files end with a newline?\u003C/a\u003E\n\nDefault = true\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let a = 42\n    \u0022\u0022\u0022\n    { FormatConfig.Default with InsertFinalNewline = false }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_space_before_parameter\u0022 orange\u003E\u003C/fantomas-setting\u003E\n\nAdd a space after the name of a function and before the opening parenthesis of the first parameter.  \nThis setting influences function definitions.\n\nDefault = true.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n   let value (a: int) = x\n   let DumpTrace() = ()\n    \u0022\u0022\u0022\n    { FormatConfig.Default with SpaceBeforeParameter = false }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_space_before_lowercase_invocation\u0022 orange\u003E\u003C/fantomas-setting\u003E\n\nAdd a space after the name of a lowercased function and before the opening parenthesis of the first argument.  \nThis setting influences function invocation in expressions and patterns.\n\nDefault = true.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \nvalue (a, b)\nstartTimer ()\n\nmatch x with\n| value (a, b) -\u003E ()\n    \u0022\u0022\u0022\n    { FormatConfig.Default with SpaceBeforeLowercaseInvocation = false }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_space_before_uppercase_invocation\u0022 green gr\u003E\u003C/fantomas-setting\u003E\n\nAdd a space after the name of a uppercase function and before the opening parenthesis of the first argument.  \nThis setting influences function invocation in expressions and patterns.\n\nDefault = false.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \nValue(a, b)\nperson.ToString()\n\nmatch x with\n| Value(a, b) -\u003E ()\n    \u0022\u0022\u0022\n    { FormatConfig.Default with SpaceBeforeUppercaseInvocation = true }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_space_before_class_constructor\u0022 orange\u003E\u003C/fantomas-setting\u003E\n\nAdd a space after a type name and before the class constructor.\n\nDefault = false.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    type Person() =\n        class\n        end\n    \u0022\u0022\u0022\n    { FormatConfig.Default with SpaceBeforeClassConstructor = true }\n\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_space_before_member\u0022 green gr\u003E\u003C/fantomas-setting\u003E\n\nAdd a space after a member name and before the opening parenthesis of the first parameter.\n\nDefault = false.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    type Person() =\n        member this.Walk(distance: int) = ()\n        member this.Sleep() = ignore\n        member __.singAlong() = ()\n        member __.swim(duration: TimeSpan) = ()\n    \u0022\u0022\u0022\n    { FormatConfig.Default with SpaceBeforeMember = true }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_space_before_colon\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nAdd a space before \u0060:\u0060. Please note that not every \u0060:\u0060 is controlled by this setting.\n\nDefault = false.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n   type Point = { x: int; y: int }\n   let myValue: int = 42\n   let update (msg: Msg) (model: Model) : Model = model\n    \u0022\u0022\u0022\n    { FormatConfig.Default with SpaceBeforeColon = true }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_space_after_comma\u0022 orange\u003E\u003C/fantomas-setting\u003E\n\nAdds a space after \u0060,\u0060 in tuples.\n\nDefault = true.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    myValue.SomeFunction(foo, bar, somethingElse)\n    (a, b, c)\n    \u0022\u0022\u0022\n    { FormatConfig.Default with SpaceAfterComma = false }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_space_before_semicolon\u0022 green gr\u003E\u003C/fantomas-setting\u003E\n\nAdds a space before \u0060;\u0060 in records, arrays, lists, etc.\n\nDefault = false.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let a = [ 1 ; 2 ; 3 ]\n    let b = [| foo ; bar |]\n    type C = { X: int ; Y: int }\n    \u0022\u0022\u0022\n    { FormatConfig.Default with SpaceBeforeSemicolon = true }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_space_after_semicolon\u0022 orange\u003E\u003C/fantomas-setting\u003E\n\nAdds a space after \u0060;\u0060 in records, arrays, lists, etc.\n\nDefault = true.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let a = [ 1; 2; 3 ]\n    let b = [| foo; bar |]\n    type C = { X: int; Y: int }\n    \u0022\u0022\u0022\n    { FormatConfig.Default with SpaceAfterSemicolon = false }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_space_around_delimiter\u0022 orange\u003E\u003C/fantomas-setting\u003E\n\nAdds a space around delimiters like \u0060[\u0060,\u0060[|\u0060,{\u0060.\n\nDefault = true.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let a = [ 1;2;3 ]\n    let b = [| 4;5;6 |]\n    \u0022\u0022\u0022\n    { FormatConfig.Default with SpaceAroundDelimiter = false }\n(*** include-it ***)\n\n(**\n## Maximum width constraints\n\nSettings that control the max width of certain expressions.\n\n\u003Cfantomas-setting name=\u0022fsharp_max_if_then_short_width\u0022 orange\u003E\u003C/fantomas-setting\u003E\n\nControl the maximum length for which if/then expression without an else expression can be on one line.  \nThe [Microsoft F# style guide](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting#formatting-if-expressions) recommends to never write such an expression in one line.\n\n\u003E If the else expression is absent, it is recommended to never to write the entire expression in one line.\n\nDefault = 0.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    if a then \n        ()\n    \u0022\u0022\u0022\n    { FormatConfig.Default with MaxIfThenShortWidth = 15 }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_max_if_then_else_short_width\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nFantomas by default follows the if/then/else conventions listed in the [Microsoft F# style guide](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting#formatting-if-expressions).  \nThis setting facilitates this by determining the maximum character width where the if/then/else expression stays in one line.\n\nDefault = 40.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    if myCheck then truth else bogus\n    \u0022\u0022\u0022\n    { FormatConfig.Default with MaxIfThenElseShortWidth = 10 }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_max_infix_operator_expression\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nControl the maximum length for which infix expression can be on one line.\n\nDefault = 50.\n*)\nformatCode\n    \u0022\u0022\u0022 \n    let WebApp =\n        route \u0022/ping\u0022 \u003E=\u003E authorized \u003E=\u003E text \u0022pong\u0022\n    \u0022\u0022\u0022\n    { FormatConfig.Default with MaxInfixOperatorExpression = 20 }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_max_record_width\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nControl the maximum width for which records should be in one line.\n\nDefault = 40.\n\nRequires \u0060fsharp_record_multiline_formatter\u0060 to be \u0060character_width\u0060 to take effect.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    type MyRecord = { X: int; Y: int; Length: int }\n    let myInstance = { X = 10; Y = 20; Length = 90 }\n    \u0022\u0022\u0022\n    { FormatConfig.Default with MaxRecordWidth = 20 }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_max_record_number_of_items\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nControl the maximum number of fields for which records should be in one line.\n\nDefault = 1.\n\nRequires \u0060fsharp_record_multiline_formatter\u0060 to be\n\u0060number_of_items\u0060 to take effect.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    type R = { x: int }\n\n    type S = { x: int; y: string }\n\n    type T = { x: int; y: string; z: float }\n\n    let myRecord = { r = 3 }\n\n    let myRecord\u0027 = { r with x = 3 }\n\n    let myRecord\u0027\u0027 = { r with x = 3; y = \u0022hello\u0022 }\n\n    let myRecord\u0027\u0027\u0027 = { r with x = 3; y = \u0022hello\u0022; z = 0.0 }\n    \u0022\u0022\u0022\n    { FormatConfig.Default with\n        MaxRecordNumberOfItems = 2\n        RecordMultilineFormatter = MultilineFormatterType.NumberOfItems }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_record_multiline_formatter\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nSplit records expressions/statements into multiple lines based on the given condition.  \n\u0060character_width\u0060 uses character count of the expression, controlled by \u0060fsharp_max_record_width\u0060.  \n\u0060number_of_items\u0060 uses the number of fields in the record, controlled by \u0060fsharp_max_record_number_of_items\u0060.\n\nDefault = \u0060character_width\u0060. \n\nNote that in either case, record expressions/statements are still governed by \u0060max_line_length\u0060.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    type R = { x: int }\n\n    type S = { x: int; y: string }\n\n    let myRecord = { r = 3 }\n\n    let myRecord\u0027 = { r with x = 3 }\n\n    let myRecord\u0027\u0027 = { r with x = 3; y = \u0022hello\u0022 }\n    \u0022\u0022\u0022\n    { FormatConfig.Default with RecordMultilineFormatter = MultilineFormatterType.NumberOfItems }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_max_array_or_list_width\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nControl the maximum width for which lists and arrays can be in one line. \n\nDefault= 40. \n\nRequires \u0060fsharp_array_or_list_multiline_formatter\u0060 to be \u0060character_width\u0060 to take effect\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let myArray = [| one; two; three |]\n    \u0022\u0022\u0022\n    { FormatConfig.Default with MaxArrayOrListWidth = 20 }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_max_array_or_list_number_of_items\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nControl the maximum number of elements for which lists and arrays can be in one line.\n\nDefault = 1.\n\nRequires \u0060fsharp_array_or_list_multiline_formatter\u0060 to be \u0060number_of_items\u0060 to take effect.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let myList = [ one; two ]\n    let myArray = [| one; two; three |]\n    \u0022\u0022\u0022\n    { FormatConfig.Default with\n        MaxArrayOrListNumberOfItems = 2\n        ArrayOrListMultilineFormatter = MultilineFormatterType.NumberOfItems }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_array_or_list_multiline_formatter\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nSplit arrays and lists into multiple lines based on the given condition.  \n\u0060character_width\u0060 uses character count of the expression, controlled by \u0060fsharp_max_array_or_list_width\u0060.  \n\u0060number_of_items\u0060 uses the number of elements in the array or list, controlled by \u0060fsharp_max_array_or_list_number_of_items\u0060.\n\nDefault = \u0060character_width\u0060.\n\nNote that in either case, list expressions are still governed by \u0060max_line_length\u0060.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let myArray = [| one; two; three |]\n    \u0022\u0022\u0022\n    { FormatConfig.Default with ArrayOrListMultilineFormatter = MultilineFormatterType.NumberOfItems }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_max_value_binding_width\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nControl the maximum expression width for which let and member value/property bindings should be in one line.  \nThe width is that of the pattern for the binding plus the right-hand expression but not the keywords (e.g. \u0022let\u0022).\n\nDefault = 80.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let title = \u0022Great title of project\u0022\n    type MyType() =\n        member this.HelpText = \u0022Some help text\u0022\n    \u0022\u0022\u0022\n    { FormatConfig.Default with MaxValueBindingWidth = 10 }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_max_function_binding_width\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nControl the maximum width for which function and member bindings should be in one line.  \nIn contrast to \u0060fsharp_max_value_binding_width\u0060, only the right-hand side expression of the binding is measured.\n\nDefault = 40\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let title = \u0022Great title of project\u0022\n    type MyType() =\n        member this.HelpText = \u0022Some help text\u0022\n    \u0022\u0022\u0022\n    { FormatConfig.Default with MaxFunctionBindingWidth = 10 }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_max_dot_get_expression_width\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nControl the maximum width for which (nested) [SynExpr.DotGet](https://fsharp.github.io/fsharp-compiler-docs/reference/fsharp-compiler-syntax-synexpr.html#DotGet) expressions should be in one line.\n\nDefault = 50.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n   let job =\n    JobBuilder\n        .UsingJobData(jobDataMap)\n        .Create\u003CWrapperJob\u003E()\n        .Build()\n    \u0022\u0022\u0022\n    { FormatConfig.Default with MaxDotGetExpressionWidth = 100 }\n(*** include-it ***)\n\n(**\n## G-Research style\n\nA series of settings required to conform with the [G-Research style guide](https://github.com/G-Research/fsharp-formatting-conventions).  \nFrom a consistency point of view, it is recommend to enable all these settings instead of cherry-picking a few.\n\n\u003Cfantomas-setting name=\u0022fsharp_multiline_block_brackets_on_same_column\u0022 green gr\u003E\u003C/fantomas-setting\u003E\n\nAlternative way of formatting records, arrays and lists. This will align the braces at the same column level.\n\nDefault = false.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let myRecord =\n        { Level = 1\n          Progress = \u0022foo\u0022\n          Bar = \u0022bar\u0022\n          Street = \u0022Bakerstreet\u0022\n          Number = 42 }\n\n    type Range =\n        { From: float\n          To: float\n          FileName: string }\n\n    let a =\n        [| (1, 2, 3)\n           (4, 5, 6)\n           (7, 8, 9)\n           (10, 11, 12)\n           (13, 14, 15)\n           (16, 17,18)\n           (19, 20, 21) |]\n    \u0022\u0022\u0022\n    { FormatConfig.Default with MultilineBlockBracketsOnSameColumn = true }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_newline_between_type_definition_and_members\u0022 green gr\u003E\u003C/fantomas-setting\u003E\n\nAdds a new line between a type definition and its first member.\n\nDefault = false.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    type Range =\n    { From: float\n      To: float }\n    member this.Length = this.To - this.From\n    \u0022\u0022\u0022\n    { FormatConfig.Default with NewlineBetweenTypeDefinitionAndMembers = true }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_align_function_signature_to_indentation\u0022 green gr\u003E\u003C/fantomas-setting\u003E\n\nWhen a function signature exceeds the \u0060max_line_length\u0060, Fantomas will put all parameters on separate lines.  \nThis setting also places the equals sign and return type on a new line.\n\nDefault = false.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    [\u003CFunctionName(\u0022FormatCode\u0022)\u003E]\n    let run \n        ([\u003CHttpTrigger(AuthorizationLevel.Anonymous, \u0022get\u0022, \u0022post\u0022, Route = \u0022{*any}\u0022)\u003E] req: HttpRequest)\n        (log: ILogger)\n        : HttpResponse =\n        Http.main CodeFormatter.GetVersion format FormatConfig.FormatConfig.Default log req\n    \u0022\u0022\u0022\n    { FormatConfig.Default with AlignFunctionSignatureToIndentation = true }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_alternative_long_member_definitions\u0022 green gr\u003E\u003C/fantomas-setting\u003E\n\nProvides an alternative way of formatting long member and constructor definitions,\nwhere the difference is mainly in the equal sign and returned type placement.\n\nDefault = false.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    type C\n        (\n            aVeryLongType: AVeryLongTypeThatYouNeedToUse,\n            aSecondVeryLongType: AVeryLongTypeThatYouNeedToUse,\n            aThirdVeryLongType: AVeryLongTypeThatYouNeedToUse\n        ) =\n        class\n        end\n\n    type D() =\n        member _.LongMethodWithLotsOfParameters\n            (\n                aVeryLongParam: AVeryLongTypeThatYouNeedToUse,\n                aSecondVeryLongParam: AVeryLongTypeThatYouNeedToUse,\n                aThirdVeryLongParam: AVeryLongTypeThatYouNeedToUse\n            ) : ReturnType =\n            42\n    \u0022\u0022\u0022\n    { FormatConfig.Default with AlternativeLongMemberDefinitions = true }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_multi_line_lambda_closing_newline\u0022 green gr\u003E\u003C/fantomas-setting\u003E\n\nPlaces the closing parenthesis of a multiline lambda argument on the next line.\n\nDefault = false.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let printListWithOffset a list1 =\n        List.iter\n            (fun { ItemOne = a } -\u003E\n                // print\n                printfn \u0022%s\u0022 a)\n            list1\n\n    let printListWithOffset a list1 =\n        list1\n        |\u003E List.iter\n            (fun elem -\u003E\n                // print stuff\n                printfn \u0022%d\u0022 (a \u002B elem))\n\n    \u0022\u0022\u0022\n    { FormatConfig.Default with MultiLineLambdaClosingNewline = true }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_experimental_keep_indent_in_branch\u0022 orange gr\u003E\u003C/fantomas-setting\u003E\n\nBreaks the normal indentation flow for the last branch of a pattern match or if/then/else expression.  \nOnly when the last pattern match or else branch was already at the same level of the entire match or if expression.\n\n*This feature is considered experimental and is subject to change.*\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let main argv =\n    let args = parse argv\n\n    let instructions = Library.foo args\n\n    if args.DryRun = RunMode.Dry then\n        printfn \u0022Would execute actions, but --dry-run was supplied: %\u002BA\u0022 instructions\n        0\n    else\n\n    // proceed with main method\n    let output = Library.execute instructions\n    // do more stuff\n    0\n    \u0022\u0022\u0022\n    { FormatConfig.Default with ExperimentalKeepIndentInBranch = true }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_bar_before_discriminated_union_declaration\u0022 green gr\u003E\u003C/fantomas-setting\u003E\n\nAlways use a \u0060|\u0060 before every case in the declaration of a discriminated union.  \nIf \u0060false\u0060, a \u0060|\u0060 character is used only in multiple-case discriminated unions, and is omitted in short single-case DUs.\n\nDefault = false.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    type MyDU = Short of int\n    \u0022\u0022\u0022\n    { FormatConfig.Default with BarBeforeDiscriminatedUnionDeclaration = true }\n\n(*** include-it ***)\n\n(**\n## Other\n\nSome additional settings that don\u0027t fit into any style guide.\n\n\u003Cfantomas-setting name=\u0022fsharp_experimental_stroustrup_style\u0022 orange\u003E\u003C/fantomas-setting\u003E\n\nPlease contribute to [fsprojects/fantomas#1408](https://github.com/fsprojects/fantomas/issues/1408) and engage in [fsharp/fslang-design#706](https://github.com/fsharp/fslang-design/issues/706).\n\nDefault = false.\n\nRequires \u0060fsharp_multiline_block_brackets_on_same_column\u0060 to be \u0060true\u0060 to take effect.\n*)\n\nformatCode\n    \u0022\u0022\u0022\ntype PostalAddress =\n    { Address: string\n      City: string\n      Zip: string }\n\u0022\u0022\u0022\n    { FormatConfig.Default with\n        MultilineBlockBracketsOnSameColumn = true\n        ExperimentalStroustrupStyle = true }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_blank_lines_around_nested_multiline_expressions\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nSurround **nested** multi-line expressions with blank lines.  \nExisting blank lines are always preserved (via trivia), with exception when [fsharp_keep_max_number_of_blank_lines](#fsharp_keep_max_number_of_blank_lines) is used.  \nTop level expressions will always follow the [2020 blank lines revision](https://github.com/fsprojects/fantomas/blob/main/docs-old/FormattingConventions.md#2020-revision) principle.\n\nDefault = true.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    let topLevelFunction () =\n        printfn \u0022Something to print\u0022\n\n        try\n                nothing ()\n        with\n        | ex -\u003E\n            splash ()\n        ()\n\n    let secondTopLevelFunction () =\n        // ...\n        ()\n    \u0022\u0022\u0022\n    { FormatConfig.Default with BlankLinesAroundNestedMultilineExpressions = false }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_keep_max_number_of_blank_lines\u0022 green\u003E\u003C/fantomas-setting\u003E\n\nSet maximal number of consecutive blank lines to keep from original source. It doesn\u0027t change number of new blank lines generated by Fantomas.\n\nDefault=100\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    open Foo\n\n    let x = 42\n    \u0022\u0022\u0022\n    { FormatConfig.Default with KeepMaxNumberOfBlankLines = 1 }\n(*** include-it ***)\n\n(**\n\u003Cfantomas-setting name=\u0022fsharp_strict_mode\u0022 red\u003E\u003C/fantomas-setting\u003E\n\nIf being set, pretty printing is only done via ASTs. Compiler directives, inline comments and block comments will be ignored.  \nThere are numerous situations when the information in the AST alone cannot restore the original code.\n\n**Please do not use this setting for formatting hand written code!**\n\nValid use-case of this settings is code generation in projects like [FsAst](https://github.com/ionide/FsAst) and [Myriad](https://github.com/MoiraeSoftware/myriad).\n\nDefault = false.\n*)\n\nformatCode\n    \u0022\u0022\u0022 \n    // some great comment\n    let add a b =\n    #if INTERACTIVE\n        42\n    #else\n        a \u002B b\n    #endif\n    \u0022\u0022\u0022\n    { FormatConfig.Default with StrictMode = true }\n(*** include-it ***)\n(**\n\u003Cfantomas-nav previous=\u0022./StyleGuide.html\u0022 next=\u0022./IgnoreFiles.html\u0022\u003E\u003C/fantomas-nav\u003E\n\n*)"},{"uri":"/fantomas/docs/end-users/FormattingCheck.html","title":"Formatting Check\n","content":"---\ncategory: End-users\ncategoryindex: 1\nindex: 5\n---\n\n# Formatting Check\n\nFormatting source code is a habit, a step in your developer workflow.  \nThe benefits of consistently formatting is that **your delta** (*typically the changes in the files of a pull request*) will be the **smallest set possible** if every previous change was formatted.\n\n## The tragedy of the ancient Greek developers\n\nWhen working with multiple people on the same code base, it is important (to some degrees) that you cannot distinguish who wrote the code.\nIf you agree as a team that you need to write unit tests to guarantee the code quality, you expect every developer to cover any new code with a test.  \nFormatting is no different, every developer should do it and it is an acceptance criteria for new code.\n\nImagine we have multiple developers in our team. Hektor made the initial setup and during a team meeting it was decided that the code should always be formatted.  \nOnce the initial project structure was delivered, Achilles made a change where the code was not formatted.  \nThe next day, Odysseus wants to submit a new pull request. As agreed code should be formatted, so Odysseus did exactly that.\nAs the changes Achilles made were not formatted, there was more code touched than was absolutely necessary. Perseus didn\u0027t see any harm in this rectification and merge the pull request as is.\n\nA week later, a huge problem was discovered in production. There was data loss and the entire company was on fire.\nFuelled by rage and anger Hektor wanted to know who was responsible for this devastating tragedy. You guessed it, somebody\u0027s head was about to roll.\nPerseus was tasked with getting to the bottom of this mystery and eventually he located the source of the misery.  Hektor tasked him with running a \u0060git blame\u0060 command, to see who the culprit really was.\n\nOdysseus credentials showed up, but it was the function Achilles originally wrote. Unable to escape Hektor\u0027s wrath, Odysseus was fired immediately.\nAchilles felt bad but couldn\u0027t come clean as he was about to get surgery for his heel. Odysseus took the fall like a true hero.\nBut it lead him to a downwards spiral and would take him ten years before he could land another job in the software industry.\n\n### Aftermath\n\nThe team was shocked by what had transpired. Besides Hektor overreacting, another painful meeting was planned to have a retrospective on the past events.  \nAfter asking five why\u0027s, the team had to brainstorm on how to avoid these things.\n\nUltimately, that meeting was mostly about the contents of the function Achilles wrote, but to end on a high note, the team discussed formatting source code afterwards.\n\nThe moral of this story is that there are two things that could have saved Odysseus: **a formatting check during continuous integration** and a \u0060.git-blame-ignore-revs\u0060 file.\n\n## --check\n\n*starting version 3.3*\n\nVerify that a single file or folder was formatted correctly.\n\n\u003E dotnet fantomas --check Source.fs\n\nThis will verify if the file \u0060Source.fs\u0060 still needs formatting.\nIf it does, the process will return exit code **99**.\nIn the case that the file does not require any formatting, exit code 0 is returned.\nUnexpected errors will return exit code 1.\n\nThis scenario is meant to be executed in a continuous integration environment, to enforce that the newly added code was formatted correctly.\n\n### FAKE\n\nIf you are using \u0060FAKE\u0060 by any chance, a good step is to have \u0060CheckFormat\u0060 target early on in the pipeline.\n\n\u0060\u0060\u0060fsharp\nTarget.create \u0022CheckFormat\u0022 (fun _ -\u003E\n    let result =\n        DotNet.exec id \u0022fantomas ourSourceFolder --recurse --check\u0022\n\n    if result.ExitCode = 0 then\n        Trace.log \u0022No files need formatting\u0022\n    elif result.ExitCode = 99 then\n        failwith \u0022Some files need formatting, run \\\u0022dotnet fantomas  ourSourceFolder --recurse\\\u0022 to resolve this.\u0022\n    else\n        Trace.logf \u0022Errors while formatting: %A\u0022 result.Errors)\n        \n// ... more targets\n\n\u0022Clean\u0022\n==\u003E \u0022CheckFormat\u0022\n==\u003E \u0022Build\u0022\n==\u003E \u0022UnitTests\u0022\n==\u003E \u0022Benchmark\u0022\n==\u003E \u0022Pack\u0022\n==\u003E \u0022Docs\u0022\n==\u003E \u0022All\u0022\n\nTarget.runOrDefault \u0022All\u0022\n\u0060\u0060\u0060\n\nThe recommendation is to install \u0060fantomas\u0060 as a local tool and run it using the generic \u0060DotNet.exec\u0060 api.\nThis translates to running \u0060dotnet fantomas ourSourceFolder --recurse --check\u0060.\n\n### Any other continuous integration environment\n\nYou want to restore your local \u0060fantomas\u0060 tool using \u0060dotnet tool restore\u0060.\nNext, you want to run \u0060dotnet fantomas \u003Cinput\u003E --check\u0060 and make sure your continuous integration environment **fails** your job when **a non-zero exit code** is returned.\n\n**Pro-tip**: print the command users need to run to fix the formatting in the output log when the check failed. This is useful for open-source projects where new contributors might never have been exposed to formatting.\n\n## A git-blame-ignore-revs file\n\nBy default, Fantomas adheres to the Microsoft [F# code formatting guidelines](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting).\nIf these change, Fantomas will follow accordingly. Due to this reason, the output cannot be guaranteed to remain the same when upgrading to a new minor version.\n\nIf you are using Git for your source control, it is recommended to ignore commits where \u0060fantomas\u0060 was updated using a [.git-blame-ignore-revs file](https://git-scm.com/docs/git-blame#Documentation/git-blame.txt---ignore-revltrevgt).\nCheck out this [blogpost](https://www.moxio.com/blog/43/ignoring-bulk-change-commits-with-git-blame) for more details.\n\nAdding a formatting commit to a configured \u0060.git-blame-ignore-revs\u0060 file will prevent you from drawing the wrong conclusions when running a \u0060git blame\u0060 command.\nOne thing to note is that if you add a commit SHA to a \u0060.git-blame-ignore-revs\u0060 file, you cannot squash the commit when merging in the pull request.\n\n## Checking is good for regressions\n\nNormally, the rule of thumb is that the code style will not change between revisions.  \nIf you are using \u00604.7.2\u0060, then it should be safe for you upgrade to the latest \u00604.7.X\u0060 without seeing any changes.\n\n\u003E Life happens, so this is a best effort guarantee\n\nIn case you do see a change that cannot be linked to anything in the [CHANGELOG.md](https://github.com/fsprojects/fantomas/blob/main/CHANGELOG.md) file, you may have detected a regression.  \nOr, more likely, you have something slightly different in your code base that isn\u0027t covered yet by a unit test.\n\nNo matter the case, when you have a \u0060--check\u0060 command somewhere in your continuous integration environment, please consider running a build with the latest compatible version from time to time.  \nIt really helps us spotting problems early on and we can more easily pinpoint the problem due to lesser recent changes.\n\n\u003Cfantomas-nav previous=\u0022./IgnoreFiles.html\u0022 next=\u0022./GitHooks.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/end-users/VisualStudio.html","title":"Visual Studio\n","content":"---\ncategory: End-users\ncategoryindex: 1\nindex: 7\n---\n# Visual Studio\nThe F# Formatting extension sets up Fantomas as the default formatter for F# files, configurable from Visual Studio\u0027s options.  \nDo note that the extension might not be up to date with the latest version of Fantomas.  \n\n* [Visual Studio 2019](https://marketplace.visualstudio.com/items?itemName=asti.fantomas-vs)\n* [Visual Studio 2022](https://marketplace.visualstudio.com/items?itemName=asti.fantomas-vs22)\n\n### Visual Studio for Mac\n\n1. Install [fantomas](https://www.nuget.org/packages/fantomas) locally with \u0060dotnet tool install fantomas\u0060 and configure it as an External Tool.\n2. Open the external tool window by going to Tools -\u003E Edit custom tools\n3. Click Add and fill in the information  \n4. Run fantomas inside Tools -\u003E fantomas\n  \n\u003Cimg src=\u0022{{root}}/images/vsmac-external-tool.png\u0022 alt=\u0022drawing\u0022 width=\u002270%\u0022/\u003E\n\n\u003Cfantomas-nav previous=\u0022./Rider.html\u0022 next=\u0022./VSCode.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/end-users/GettingStarted.html","title":"Getting Started\n","content":"---\ncategory: End-users\ncategoryindex: 1\nindex: 1\n---\n# Getting Started\n\nFantomas should be installed as a [.NET tool](https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools).  \nIt is recommended to install it as a local tool and stick to a certain version per repository.\n\n## Installation\n\nCreate a [.NET tool manifest](https://docs.microsoft.com/en-us/dotnet/core/tools/local-tools-how-to-use) to install tools locally.\nYou can skip this step if you wish to install Fantomas globally.\n\n\u003E dotnet new tool-manifest\n\nInstall the command line tool with:\n\n\u003E dotnet tool install fantomas\n\nor install the tool globally with\n\u003E dotnet tool install -g fantomas\n\n## Usage\n\nFor the overview how to use the tool, you can type the command\n\n\tdotnet fantomas --help\n\n\u0060\u0060\u0060\nUSAGE: dotnet fantomas [--help] [--recurse] [--force] [--profile] [--fsi \u003Cstring\u003E] [--stdin] [--stdout] [--out \u003Cstring\u003E] [--check] [--daemon] [--version] [\u003Cstring\u003E...]\n\nINPUT:\n\n    \u003Cstring\u003E...           Input paths: can be multiple folders or files with *.fs,*.fsi,*.fsx,*.ml,*.mli extension.\n\nOPTIONS:\n\n    --recurse, -r         Process the input folder recursively.\n    --force               Print the source unchanged if it cannot be parsed correctly.\n    --profile             Print performance profiling information.\n    --fsi \u003Cstring\u003E        Read F# source from stdin as F# signatures.\n    --stdin               Read F# source from standard input.\n    --stdout              Write the formatted source code to standard output.\n    --out \u003Cstring\u003E        Give a valid path for files/folders. Files should have .fs, .fsx, .fsi, .ml or .mli extension only.\n    --check               Don\u0027t format files, just check if they have changed. Exits with 0 if it\u0027s formatted correctly, with 1 if some files need formatting and 99 if there was an internal error\n    --daemon              Daemon mode, launches an LSP-like server to can be used by editor tooling.\n    --version, -v         Displays the version of Fantomas\n    --help                display this list of options.\n\n\u0060\u0060\u0060\n\nYou have to specify an input path and optionally an output path. \nThe output path is prompted by \u0060--out\u0060 e.g.\n\n\tdotnet fantomas ./input/array.fs --out ./output/array.fs \n\nBoth paths have to be files or folders at the same time. \nIf they are folders, the structure of input folder will be reflected in the output one. \nThe tool will explore the input folder recursively if you set \u0060--recurse\u0060 option.\nIf you omit the output path, Fantomas will overwrite the input files unless the content did not change.\n\n\n### Multiple paths\n\n*starting version 4.5*\n\nMultiple paths can be passed as last argument, these can be both files and folders.  \nThis cannot be combined with the \u0060--out\u0060 flag.  \nWhen combined with the \u0060--recurse\u0060 flag, all passed folders will be processed recursively.\n\nOne interesting use-case of passing down multiple paths is that you can easily control the selection and filtering of paths from the current shell.\n\nConsider the following PowerShell script:\n\n\u0060\u0060\u0060powershell\n# Filter all added and modified files in git\n# A useful function to add to your $PROFILE\nfunction Format-Changed(){\n    $files = \n        git status --porcelain \u0060\n        | Where-Object { ($_.StartsWith(\u0022 M\u0022) -or $_.StartsWith(\u0022AM\u0022)) \u0060\n        -and (Test-FSharpExtension $_) } | ForEach-Object { $_.substring(3) }\n    \u0026 \u0022dotnet\u0022 \u0022fantomas\u0022 $files\n}\n\u0060\u0060\u0060\n\nOr usage with \u0060find\u0060 on Unix:\n\n\u0060\u0060\u0060bash\nfind my-project/ -type f -name \u0022*.fs\u0022 -not -path \u0022*obj*\u0022 | xargs dotnet fantomas --check\n\u0060\u0060\u0060\n\n\u003Cfantomas-nav previous=\u0022../index.html\u0022 next=\u0022./StyleGuide.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/end-users/Rider.html","title":"JetBrains Rider\n","content":"---\ncategory: End-users\ncategoryindex: 1\nindex: 7\n---\n# JetBrains Rider\nThe resharper-fsharp uses Fantomas under the hood to format the source code. No need for any additional plugins.  \n  \nFrom Rider 2022.2 onwards, Rider can detect your \u0060dotnet\u0060 Fantomas installation, either globally or locally.  \nInstall Fantomas locally with \u0060dotnet tool install fantomas\u0060.\n\n\u003Cimg class=\u0022mt-2\u0022 src=\u0022{{root}}/images/rider-fantomas.png\u0022 alt=\u0022drawing\u0022 width=\u002270%\u0022/\u003E\n\nAt the time of writing, Rider versions prior to the not yet released 2022.3 [overwrite](https://youtrack.jetbrains.com/issue/RIDER-83997/Rider-doesnt-respect-Fantomas-default-settings-not-explicitly-set-in-editorconfig)\nthe settings of Fantomas which aren\u0027t explicitly set in your editorconfig file.  \nAs the settings chosen by Rider can lead to unwanted results, Rider users might want to also include the default settings in their editorconfig file.\n\nFortunately, with 2022.3 the Rider developers changed the settings chosen by Rider to be the same as the default Fantomas settings.  \nThis means, as long as the Fantomas default settings don\u0027t change, the described issue should be solved with Rider 2022.3.  \nThe current default settings are the following:\n\n\u0060\u0060\u0060\nindent_size=4\nmax_line_length=120\nend_of_line=crlf\ninsert_final_newline=true \nfsharp_space_before_parameter=true \nfsharp_space_before_lowercase_invocation=true \nfsharp_space_before_uppercase_invocation=false\nfsharp_space_before_class_constructor=false\nfsharp_space_before_member=false\nfsharp_space_before_colon=false\nfsharp_space_after_comma=true \nfsharp_space_before_semicolon=false\nfsharp_space_after_semicolon=true \nfsharp_space_around_delimiter=true \nfsharp_max_if_then_short_width=0\nfsharp_max_if_then_else_short_width=60\nfsharp_max_infix_operator_expression=80\nfsharp_max_record_width=40\nfsharp_max_record_number_of_items=1\nfsharp_record_multiline_formatter=character_width\nfsharp_max_array_or_list_width=80\nfsharp_max_array_or_list_number_of_items=1\nfsharp_array_or_list_multiline_formatter=character_width\nfsharp_max_value_binding_width=80\nfsharp_max_function_binding_width=40\nfsharp_max_dot_get_expression_width=80\nfsharp_multiline_block_brackets_on_same_column=false\nfsharp_newline_between_type_definition_and_members=true \nfsharp_align_function_signature_to_indentation=false\nfsharp_alternative_long_member_definitions=false\nfsharp_multi_line_lambda_closing_newline=false\nfsharp_experimental_keep_indent_in_branch=false\nfsharp_blank_lines_around_nested_multiline_expressions=true \nfsharp_bar_before_discriminated_union_declaration=false\nfsharp_experimental_stroustrup_style=false\nfsharp_keep_max_number_of_blank_lines=100\nfsharp_strict_mode=false\n\u0060\u0060\u0060\n\n\u003Cfantomas-nav previous=\u0022./GitHooks.html\u0022 next=\u0022./VisualStudio.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/end-users/StyleGuide.html","title":"Style guide\n","content":"---\ncategory: End-users\ncategoryindex: 1\nindex: 2\n---\n# Style guide\n\nFantomas tries to adhere to two F# style guides:\n- [Microsoft](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting)\n- [G-Research](https://github.com/G-Research/fsharp-formatting-conventions)\n\nBy default Fantomas  will format the code according to the Microsoft guide.   \nThe benefit of these guides is that this allows us, as the F# community, to write code in the same manner.  \n\n## Let it go\n\nIf you are not used to having a code formatter, you might struggle a bit at first. A part of using a code formatter is about letting go how you wrote things and accept a common consistent style instead.  \nWhen embraced, this can truly be **a liberation feeling**. You can play _jazz_ while typing the code, focus on the task at hand and have the same output as if anyone in your team would have written it.\n\n## A cautionary tale\n\nThe responsibility of the coding style is also a shared one. The maintainers of Fantomas do not dictate how things should look like.  \nInstead, conversations are held over at [fsharp/fslang-design](https://github.com/fsharp/fslang-design#style-guide).  \n\nOver the years, a lot of consumers of Fantomas have requested numerous features. These often go against the philosophy of being consistent amongst the community.\nIf there were a _gazillion of settings_ to please everybody it would be a _missed opportunity_ to see all F# code bases in the same style.  \n\nAnd more importantly the maintenance cost of each setting is always carried by only a handful of people. **The hardship of having a setting is so high that in almost all cases it is not worth having it**.  \nEven when someone proposes to contribute the setting, it always leads to lament and sorrow for the maintainers to carry. \n\n## Default style guide\n\nAs mentioned, the default style guide is not to be discussed on the Fantomas repository. The majority of the maintainers is burnt out talking about style at this point.  \nIf you want to discuss the style, you are more than welcome on [fsharp/fslang-design](https://github.com/fsharp/fslang-design#style-guide).  \n\nHowever, we greatly encourage that you take some time to **understand the Fantomas code base**.  Having an opinion on code style is easy, everybody writes code so we all have our thoughts and feelings about it.\nBeing able to **translate your thoughts/opinions** and **prototyping them in Fantomas** will gain you a **much larger insight** on how quickly things can get quite complex.  \n\nAt the end of the day, if some new idea is validated on \u0060fsharp/fslang-design\u0060, it needs to be:\n\n- Documented in the style guide (over at [dotnet/docs](https://github.com/dotnet/docs/blob/main/docs/fsharp/style-guide/formatting.md))\n- Implemented in \u0060Fantomas\u0060\n\n\u003E There\u2019s no such thing as a free lunch, so please consider all aspects of debating code style.\n\n## G-Research Style\n\n[G-Research](https://www.gresearch.co.uk/) has been our _single enterprise sponsor_ for the last five years. **Fantomas would not exist** in it\u0027s current form if it were **not for their support**.  \nTheir interest was to have a tool that automatically format code according to their _internal guidelines_. These have been made available publicly and can be turned on via [various settings](https://github.com/G-Research/fsharp-formatting-conventions/blob/master/.editorconfig).\n\n## Recommendations\n\nTo strengthen the message of unity we advice that you do not change the default settings.\nThe **out-of-the-box experience** should be a result of what the **brightest minds of the community** came up with.\nIf you are _new_ to the F# language, this is what you want.\n\n\u003Cfantomas-nav previous=\u0022./GettingStarted.html\u0022 next=\u0022./Configuration.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/end-users/GitHooks.html","title":"Git hooks\n","content":"---\ncategory: End-users\ncategoryindex: 1\nindex: 6\n---\n# Git hooks\n## A git pre-commit hook sample\n\nA very elegant and transparent way to use Fantomas is including it in a pre-commit git hook, by creating a \u0060.git/hooks/pre-commit\u0060 file with:\n##### Using fantomas globally\n\u0060\u0060\u0060\n#!/bin/sh\ngit diff --cached --name-only --diff-filter=ACM -z | xargs -0 $HOME/.dotnet/tools/fantomas\ngit diff --cached --name-only --diff-filter=ACM -z | xargs -0 git add\n\u0060\u0060\u0060\n\nThis script assumes you have installed Fantomas globally as a [dotnet tool](https://www.nuget.org/packages/fantomas/)\n##### Using fantomas locally\n\u0060\u0060\u0060\n#!/bin/sh\ngit diff --cached --name-only --diff-filter=ACM -z | xargs -0 dotnet fantomas \ngit diff --cached --name-only --diff-filter=ACM -z | xargs -0 git add\n\u0060\u0060\u0060\n\n**Please use with caution** as [Fantomas is not without bugs](https://github.com/fsprojects/fantomas/issues?q=is%3Aissue\u002Bis%3Aopen\u002Blabel%3A%22bug\u002B%28soundness%29%22).\n\n\u003Cfantomas-nav previous=\u0022./FormattingCheck.html\u0022 next=\u0022./Rider.html\u0022\u003E\u003C/fantomas-nav\u003E\n"},{"uri":"/fantomas/docs/end-users/GeneratingCode.html","title":"Generating source code\n","content":"(**\n---\ncategory: End-users\ncategoryindex: 1\nindex: 9\n---\n*)\n(**\n# Generating source code\n\nThe [Fantomas.Core](https://www.nuget.org/packages/Fantomas.Core) NuGet package can also be used to format code programmatically.   \nThe public API is available from the static \u0060CodeFormatter\u0060 class. It exposes a couple of APIs to format code, one being to format code from a raw syntax tree.  \nThis API assumes the user already parsed a syntax tree or constructed an artificial one.\n\n## Key motivation\n\nIt can be very tempting to generate some F# code by doing some string concatenations.  \nIn simple scenarios this can work out, but in the long run it doesn\u0027t scale well:\n\n- The more code constructs you want to support, the more conditional logic you will need to ensure all edge cases.\n- A string is just a string, you cannot guarantee the output will be valid code.\n- It is easier to map your domain model to untyped syntax tree nodes and let Fantomas take care of the actual generation of code.\n\n**For mercy\u0027s sake don\u0027t use string concatenation when generating F# code, use Fantomas instead. It is battle tested and proven technology!**\n*)\n\n(**\n## Generating source code from scratch\n\n### Example syntax tree\n\nTo illustrate the API, lets generate a simple value binding: \u0060let a = 0\u0060.\n*)\n\n#r \u0022nuget: Fantomas.Core, 5.0.*\u0022 // Note that this will also load Fantomas.FCS, which contains the syntax tree types.\n\nopen FSharp.Compiler.Text\nopen FSharp.Compiler.Xml\nopen FSharp.Compiler.Syntax\nopen FSharp.Compiler.SyntaxTrivia\n\nlet implementationSyntaxTree =\n    ParsedInput.ImplFile(\n        ParsedImplFileInput(\n            \u0022filename.fsx\u0022,\n            true,\n            QualifiedNameOfFile(Ident(\u0022\u0022, Range.Zero)),\n            [],\n            [],\n            [ SynModuleOrNamespace(\n                  [],\n                  false,\n                  SynModuleOrNamespaceKind.AnonModule,\n                  [ SynModuleDecl.Let(\n                        false,\n                        [ SynBinding(\n                              None,\n                              SynBindingKind.Normal,\n                              false,\n                              false,\n                              [],\n                              PreXmlDoc.Empty,\n                              SynValData(None, SynValInfo([], SynArgInfo([], false, None)), None),\n                              SynPat.Named(SynIdent(Ident(\u0022a\u0022, Range.Zero), None), false, None, Range.Zero),\n                              None,\n                              SynExpr.Const(SynConst.Int32(0), Range.Zero),\n                              Range.Zero,\n                              DebugPointAtBinding.Yes Range.Zero,\n                              { EqualsRange = Some Range.Zero\n                                LetKeyword = Some Range.Zero }\n                          ) ],\n                        Range.Zero\n                    ) ],\n                  PreXmlDoc.Empty,\n                  [],\n                  None,\n                  Range.Zero,\n                  { ModuleKeyword = None\n                    NamespaceKeyword = None }\n              ) ],\n            (false, false),\n            { ConditionalDirectives = []\n              CodeComments = [] }\n        )\n    )\n\nopen Fantomas.Core\n\nCodeFormatter.FormatASTAsync(implementationSyntaxTree) |\u003E Async.RunSynchronously\n(*** include-it ***)\n\n(**\nConstructing the entire syntax tree can be a bit overwhelming at first. There is a lot of information to provide and a lot to unpack if you have never seen any of this before.\n\nLet\u0027s deconstruct a couple of things:\n\n- Every file has one or more [SynModuleOrNamespace](../../reference/fsharp-compiler-syntax-synmoduleornamespace.html). In this case the module was anonymous and thus invisible.\n- Every \u0060SynModuleOrNamespace\u0060 has top level [SynModuleDecl](../../https://fsprojects.github.io/fantomas/reference/fsharp-compiler-syntax-synmoduledecl.html).\n- [SynModuleDecl.Let](../../https://fsprojects.github.io/fantomas/reference/fsharp-compiler-syntax-synmoduledecl.html#Let) takes one or more [SynBinding](../../reference/fsharp-compiler-syntax-synbinding.html).  \n\n  You would have multiple bindings in case of a recursive function.  \n- The \u0060headPat\u0060 of binding contains the name and the parameters. \n- The \u0060expr\u0060 ([SynExpr](../../reference/fsharp-compiler-syntax-synexpr.html)) represents the F# syntax expression.\n- Because there is no actual source code, all ranges will be \u0060Range.Zero\u0060.  \n\nThe more you interact with AST, the easier you pick up which node represents what.\n\n### Fantomas.FCS\n\nWhen looking at the example, we notice that we\u0027ve opened a couple of \u0060FSharp.Compiler.*\u0060 namespaces.   \nDon\u0027t be fooled by this, \u0060Fantomas.Core\u0060 and \u0060Fantomas.FCS\u0060 **do not reference [FSharp.Compiler.Service](https://www.nuget.org/packages/FSharp.Compiler.Service)**!  \nInstead, \u0060Fantomas.FCS\u0060 is a custom version of the F# compiler (built from source) that only exposes the F# parser and the syntax tree.\n\n\u0060Fantomas.FCS\u0060 exposes the exact same namespaces because it builds from the exact same F# compiler source code.   \nThe key difference is that \u0060Fantomas.FCS\u0060 will most likely contain a more recent version of the F# parser.  \nYou can read the [CHANGELOG](https://github.com/fsprojects/fantomas/blob/main/CHANGELOG.md) to see what git commit was used to build \u0060Fantomas.FCS\u0060.\n\nYou can use \u0060Fantomas.FCS\u0060 in your own projects, but be aware that it is **not binary compatible** with \u0060FSharp.Compiler.Service\u0060.  \nExample usage:\n\n*)\n\n#r \u0022nuget: Fantomas.FCS\u0022\n\nopen FSharp.Compiler.Text\nopen Fantomas.FCS\n\nParse.parseFile false (SourceText.ofString \u0022let a = 1\u0022) []\n(*** include-it ***)\n\n(**\n## Tips and tricks\n\n### Online tool\n\nThe syntax tree can have an overwhelming type hierarchy.  \nWe wholeheartedly recommend to use our **[online tool](https://fsprojects.github.io/fantomas-tools/#/ast)** when working with AST.\n\n![F# AST Viewer](../../images/ast-viewer.png)\n\nThis shows you what AST nodes the parser created for a given input text.  \nFrom there on you can use our search bar to find the corresponding documentation:\n\n![Search bar](../../images/searchbar-ast.png)\n\n### Match the AST the parser would produce\n\nFantomas will very selectively use information from the AST.  \nPlease make sure you construct the same AST as the parser would.\n*)\n\n// You typically make some helper functions along the way\nlet mkCodeFromExpression (e: SynExpr) : string =\n    ParsedInput.ImplFile(\n        ParsedImplFileInput(\n            \u0022filename.fsx\u0022,\n            true,\n            QualifiedNameOfFile(Ident(\u0022\u0022, Range.Zero)),\n            [],\n            [],\n            [ SynModuleOrNamespace(\n                  [],\n                  false,\n                  SynModuleOrNamespaceKind.AnonModule,\n                  [ SynModuleDecl.Expr(e, Range.Zero) ],\n                  PreXmlDoc.Empty,\n                  [],\n                  None,\n                  Range.Zero,\n                  { ModuleKeyword = None\n                    NamespaceKeyword = None }\n              ) ],\n            (false, false),\n            { ConditionalDirectives = []\n              CodeComments = [] }\n        )\n    )\n    |\u003E CodeFormatter.FormatASTAsync\n    |\u003E Async.RunSynchronously\n\nlet numberExpr = SynExpr.Const(SynConst.Int32(7), Range.Zero)\nlet wrappedNumber = SynExpr.Paren(numberExpr, Range.Zero, None, Range.Zero)\nmkCodeFromExpression wrappedNumber\n(*** include-it ***)\n\n(**\nNotice that last but one argument \u0060None\u0060, it represents the range of the closing \u0060)\u0060.  \nThe F# parser would include \u0060Some range\u0060 when it parses code, so you need to provide a \u0060Some range\u0060 value as well.  \nEven though the range is empty. Fantomas is designed to work with AST created by the parser.  \nCreating a \u0060SynExpr.Paren\u0060 node is not enough to get both parentheses!  \nThe \u0060CodeFormatter.FormatASTAsync\u0060 API is really a side-effect and not a first class citizen.  \nIt will work when you play ball with the exact shape of the parser.\n*)\n\nlet betterWrappedNumber =\n    SynExpr.Paren(numberExpr, Range.Zero, Some Range.Zero, Range.Zero)\n\nmkCodeFromExpression betterWrappedNumber\n(*** include-it ***)\n\n(**\nAs a rule of thumb: **create what the parser creates, use the online tool!**  \nJust because you can create AST nodes, does not mean Fantomas will do the right thing.\n\n### Look at the Fantomas code base\n\nAs mentioned, not every AST node is being used in Fantomas. There are numerous things that do not have any influence on the generation of code.  \nFor example creating [SynExpr.Lambda](../../reference/fsharp-compiler-syntax-synexpr.html#Lambda).\n\nWhen you want to construct \u0060fun a b -\u003E a \u002B b\u0060, the AST the online tool produces looks like:\n\u0060\u0060\u0060fsharp\nLambda\n  (false, false,\n    SimplePats\n    ([Id (a, None, false, false, false, tmp.fsx (1,4--1,5))],\n    tmp.fsx (1,4--1,5)),\n    Lambda\n    (false, true,\n    SimplePats\n        ([Id (b, None, false, false, false, tmp.fsx (1,6--1,7))],\n        tmp.fsx (1,6--1,7)),\n    App\n        (NonAtomic, false,\n        App\n            (NonAtomic, true,\n            LongIdent\n            (false,\n                SynLongIdent\n                ([op_Addition], [], [Some (OriginalNotation \u0022\u002B\u0022)]),\n                None, tmp.fsx (1,13--1,14)), Ident a,\n            tmp.fsx (1,11--1,14)), Ident b, tmp.fsx (1,11--1,16)),\n    None, tmp.fsx (1,0--1,16),\n    { ArrowRange = Some tmp.fsx (1,8--1,10) }),\n    Some\n    ([Named (SynIdent (a, None), false, None, tmp.fsx (1,4--1,5));\n        Named (SynIdent (b, None), false, None, tmp.fsx (1,6--1,7))],\n    App\n        (NonAtomic, false,\n        App\n            (NonAtomic, true,\n            LongIdent\n            (false,\n                SynLongIdent\n                ([op_Addition], [], [Some (OriginalNotation \u0022\u002B\u0022)]),\n                None, tmp.fsx (1,13--1,14)), Ident a,\n            tmp.fsx (1,11--1,14)), Ident b, tmp.fsx (1,11--1,16))),\n    tmp.fsx (1,0--1,16), { ArrowRange = Some tmp.fsx (1,8--1,10) })\n\u0060\u0060\u0060\n\nbut the Fantomas \u0060CodePrinter\u0060 does not use all this data.\nWe can easily create a \u0060Lambda\u0060 without the nested body structure, as Fantomas will use the \u0060parsedData\u0060 information.\n*)\n// this dummy expr will never be used!\nlet dummyExpr = SynExpr.Const(SynConst.Unit, Range.Zero)\n\nlet lambdaExpr =\n    let args =\n        [ SynPat.Named(SynIdent(Ident(\u0022a\u0022, Range.Zero), None), false, None, Range.Zero)\n          SynPat.Named(SynIdent(Ident(\u0022b\u0022, Range.Zero), None), false, None, Range.Zero) ]\n\n    let expr =\n        SynExpr.App(\n            ExprAtomicFlag.NonAtomic,\n            false,\n            SynExpr.App(\n                ExprAtomicFlag.NonAtomic,\n                true,\n                SynExpr.LongIdent(\n                    false,\n                    SynLongIdent(\n                        [ Ident(\u0022_actually_not_used_\u0022, Range.Zero) ],\n                        [],\n                        [ Some(IdentTrivia.OriginalNotation(\u0022\u002B\u0022)) ]\n                    ),\n                    None,\n                    Range.Zero\n\n                ),\n                SynExpr.Ident(Ident(\u0022a\u0022, Range.Zero)),\n                Range.Zero\n            ),\n            SynExpr.Ident(Ident(\u0022b\u0022, Range.Zero)),\n            Range.Zero\n        )\n\n    SynExpr.Lambda(\n        false,\n        false,\n        SynSimplePats.SimplePats([], Range.Zero), // not used\n        dummyExpr, // not used\n        Some(args, expr), // The good stuff is in here!\n        Range.Zero,\n        { ArrowRange = Some Range.Zero }\n    )\n\nmkCodeFromExpression lambdaExpr\n(*** include-it ***)\n\n(**\nNotice how minimal the AST is, versus to what the parser produced. A subset of the data was enough.  \nHow to know which nodes to include? Take a look at \u0060CodePrinter.fs\u0060 and \u0060SourceParser.fs\u0060!\n\n### Create your own set of helper functions\n\nThroughout all these examples, we have duplicated a lot of code. You can typically easily refactor this into some helper functions.  \nThe Fantomas maintainers are not affiliated with any projects that expose AST construction helpers.  \nRelying on these projects, is at your own risk. The constructed AST might not be suitable for what Fantomas expects.\n\n### Updates\n\nSince code generation is considered to be a nice to have functionality, there is no compatibility between any \u0060Fantomas.FCS\u0060.  \nWe do not apply any semantic versioning to \u0060Fantomas.FCS\u0060. Breaking changes can be expected at any given point.\n\n\u003Cfantomas-nav previous=\u0022./VSCode.html\u0022 next=\u0022./FAQ.html\u0022\u003E\u003C/fantomas-nav\u003E\n*)"},{"uri":"/fantomas/docs/end-users/FAQ.html","title":"FAQ\n","content":"---\ncategory: End-users\ncategoryindex: 1\nindex: 1000\n---\n# FAQ\n\n## Why the name \u0022Fantomas\u0022?\n\nThere are a few reasons to choose the name as such.\nFirst, it starts with an \u0022F\u0022 just like many other F# projects.\nSecond, Fantomas is my favourite character in the literature.\nFinally, Fantomas has the same Greek root as \u0022[phantom](https://en.wiktionary.org/wiki/phantom)\u0022; coincidentally F# ASTs and formatting rules are so *mysterious* to be handled correctly.\n\n## What is \u0060fantomas-tool\u0060?\n\nThat is the previous name of the dotnet tool. \u0060v4.7.9\u0060 was the last stable release under that name.  \nPlease use [fantomas](https://www.nuget.org/packages/fantomas/) instead and remove all traces of \u0060fantomas-tool\u0060 in your \u0060dotnet-tools.json\u0060 file.\n\n## Why exit code 99 for a failed format check?\n\nNo real reason, it was [suggested](https://github.com/fsprojects/fantomas/pull/655#discussion_r374849907) by the contributor [lpedrosa](https://github.com/lpedrosa).  \nIt also reminds us of a certain Jay-Z song \uD83D\uDE09.\n\n## Can I make a style suggestion?\n\nAs mention in [style guide](https://fsprojects.github.io/fantomas/docs/end-users/StyleGuide.html), Fantomas adheres to [Microsoft](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting) and [G-Research](https://github.com/G-Research/fsharp-formatting-conventions) style guidelines.  \nFor any style related suggestion, please head over to [fsharp/fslang-design](https://github.com/fsharp/fslang-design#style-guide).  \n[More context](https://fsprojects.github.io/fantomas/docs/end-users/StyleGuide.html#Default-style-guide).\n\n## Is it safe to use the Alpha version of Fantomas?\n\nPreview alpha versions are generally safe to use but there is no guarantee that the style wouldn\u0027t change due to ongoing development.  \nYou should check the [changelog](https://github.com/fsprojects/fantomas/blob/main/CONTRIBUTING.md) to see if there\u0027s any relevant change to try out in the Alpha.\n\n\u003Cfantomas-nav previous=\u0022./VSCode.html\u0022\u003E\u003C/fantomas-nav\u003E\n"}]